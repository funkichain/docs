{"searchDocs":[{"title":"Network Information","type":0,"sectionRef":"#","url":"/docs/network-information","content":"Network Information Funki Mainnet​ Name\tValueNetwork Name\tFunki Mainnet Description\tThe public mainnet for Funki. RPC Endpoint\thttps://rpc-mainnet.funkichain.com Rate limited and not for production systems. Chain ID\t33979 Currency Symbol\tETH Block Explorer\thttps://funkiscan.io Funki Testnet​ Name\tValueNetwork Name\tFunki Testnet Description\tA public testnet for Funki. RPC Endpoint\thttps://funki-testnet.alt.technology Rate limited and not for production systems. Chain ID\t3397901 Currency Symbol\tETH Block Explorer\thttps://testnet.funkiscan.io/ info L1 &amp; L2 protocol and network-related smart contract deployments can be found on the Funki Contracts page. info For production systems, we recommend using a node from one of our node partners","keywords":"Funki network Funki Mainnet Funki Testnet RPC URL Funki RPC URL Funki RPC Chain ID chainid Funki Chain ID Funki chainId network information Funki network information","version":"Next"},{"title":"Fees","type":0,"sectionRef":"#","url":"/docs/fees","content":"","keywords":"Funki fees transaction fees network fees Funki network fees L2 execution fee L1 security fee transaction costs gas fees fee calculation cost-saving transaction timing fee variations Funki platform","version":"Next"},{"title":"How do network fees on Funki work?​","type":1,"pageTitle":"Fees","url":"/docs/fees#how-do-network-fees-on-funki-work","content":" Every transaction on Funki involves two types of costs: an L2 (execution) fee and an L1 (security) fee. The L2 fee covers the cost of executing your transaction on the L2 network, while the L1 fee represents the estimated cost to record the transaction on the Ethereum L1. Typically, the L1 security fee is higher than the L2 execution fee.  The L1 fee fluctuates based on the current traffic on Ethereum L1. If your transaction timing is flexible, you can reduce costs by initiating transactions when Ethereum's gas prices are lower, such as during weekends.  Likewise, the L2 fee adjusts based on the volume of transactions being processed on the L2, similar to the dynamic mechanism used on Ethereum L1.  For more information on how fees are calculated on Funki, please visit the op-stack developer documentation. ","version":"Next","tagName":"h2"},{"title":"Differences between Ethereum and Funki","type":0,"sectionRef":"#","url":"/docs/differences","content":"Differences between Ethereum and Funki Funki is built on the Bedrock release of the OP Stack, meticulously engineered to mimic Ethereum's architecture as closely as possible. This similarity ensures that developers experience minimal differences when building on Funki compared to Ethereum. Nonetheless, there are still slight variances in how Funki and Ethereum operate, which developers should note when creating applications on Funki. These minor differences include: OpcodesBlocksNetwork specificationsTransaction costs","keywords":"Ethereum vs Funki Funki differences difference between Funki and Ethereum Bedrock OP Stack Funki opcodes Funki blocks Funki network specifications network specifications Funki transaction costs transaction costs","version":"Next"},{"title":"About Funki","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"Funki Ethereum L2 Atherlabs decentralization cryptoeconomy EVM blockchain OP Stack Optimism decentralized apps","version":"Next"},{"title":"Funki Chain - Not another Chain​","type":1,"pageTitle":"About Funki","url":"/docs/#funki-chain---not-another-chain","content":" Introducing Funki Chain, where the magic of having fun online transforms into having fun onchain. Heavily inspired by the ethos of Disney and Japanese culture, Funki Chain reimagines the blockchain experience as an interconnected world brimming with wonder, adventure, and fun!  Here, every interaction goes beyond mere technology; it becomes an experience. Every transaction, every game, and every digital asset is a chapter in an unfolding story designed to bring fun and excitement to your onchain activities. In the world of Funki Chain, inspired by Brian Armstrong’s &quot;onchain is the new online,&quot; we strive to create a vibrant realm where your digital onchain actions are infused with the fun and magic of an animated ‘wonderland’, with every interaction creating a memorable, tracable and sharable adventure. With Funki, “having fun onchain is the new fun online”  We are dedicated to turning web3 innovations into everyday casual &amp; fun experiences. You are not just to merely interact the onchain network but to be an active, celebrated part of it. Here, the blockchain isn't just a technology; instead, it’s a interconnected, living, breathing celebration of creativity, community, and fun.  We strive to transform everyday onchain interactions through games and applicatios into extraordinary events, and rediscover the excitement of being part of a community where fun comes first, memes and pachinkos included.  Funki chain is an L2 Ethereum Rollup Network, powered by the OP Stack, part of the Superchain, leveraging OP Plasma Mode and secured by Ethereum. Apart from fun, we value simplicity, pragmatism, sustainability, and, of course, optimism.  Funki is a fun first L2 that aim to reward users and builders for making onchain fun, again.  ","version":"Next","tagName":"h3"},{"title":"Fun for creators. Fun for builders​","type":1,"pageTitle":"About Funki","url":"/docs/#fun-for-creators-fun-for-builders","content":" For creators and builders, access an ecosystem where NFTs currently only existed as boring veblen goods, can have their Doraemon’s Dokodemo (Anywhere] moment, having their multiverse selves in different fun onchain experience, all connected back to the canonical NFT. Royalties are enforced and simplified Dokodemo Protocol, a Funki’s innovative approach for NFT replications.  Funki also shares of sequencer fees to the Fun First Society (FFS) which we'll reveal more details on later.  ","version":"Next","tagName":"h3"},{"title":"Contributing to the OP Superchain​","type":1,"pageTitle":"About Funki","url":"/docs/#contributing-to-the-op-superchain","content":" Funki is powered by the OP Stack, in collaboration with Optimism. We aim to contribute to growing Optimism's Superchain ecosystem as the innovative Web3 Gaming &amp; Entertainment Hub ","version":"Next","tagName":"h3"},{"title":"How to ensure ERC-20 tokens are immediately swappable in MetaMask","type":0,"sectionRef":"#","url":"/docs/tokens/adding-tokens-to-metamask","content":"","keywords":"ERC-20 token memecoin Funki MetaMask build on funki tokens token issuer meme coin swaps","version":"Next"},{"title":"Adding your token to the list​","type":1,"pageTitle":"How to ensure ERC-20 tokens are immediately swappable in MetaMask","url":"/docs/tokens/adding-tokens-to-metamask#adding-your-token-to-the-list","content":" The steps below explain how to have your token display quickly on MetaMask. These instructions work not only for Funki, but for any EVM chain supported by MetaMask (Optimism, Arbitrum, Polygon, Avalanche, Fantom, BNB).  ","version":"Next","tagName":"h2"},{"title":"Step 1: Deploy your ERC-20 Token on Funki Mainnet​","type":1,"pageTitle":"How to ensure ERC-20 tokens are immediately swappable in MetaMask","url":"/docs/tokens/adding-tokens-to-metamask#step-1-deploy-your-erc-20-token-on-funki-mainnet","content":" Write and deploy a compliant ERC-20 token smart contract. Test it and then deploy on Funki Mainnet.  ","version":"Next","tagName":"h3"},{"title":"Step 2: Prepare your metadata and asset images​","type":1,"pageTitle":"How to ensure ERC-20 tokens are immediately swappable in MetaMask","url":"/docs/tokens/adding-tokens-to-metamask#step-2-prepare-your-metadata-and-asset-images","content":" Prepare a high-resolution images of your token's logo. Ensure it is clear, identifiable, and representative of your token.  ","version":"Next","tagName":"h3"},{"title":"Step 3: List your cryptocurrency on a listing aggregator​","type":1,"pageTitle":"How to ensure ERC-20 tokens are immediately swappable in MetaMask","url":"/docs/tokens/adding-tokens-to-metamask#step-3-list-your-cryptocurrency-on-a-listing-aggregator","content":" You can list for free on Coingecko following these instructions  You can pay to be listed on CoinMarketCap following these instructions.  Once Coingecko lists your token OR CoinMarketCap lists it as verified, your asset's image logo and other metadata will flow into MetaMask and can be seen by users.  Remember, once your ERC-20 contract is deployed, your asset is swappable instantly on MetaMask.  Disclaimer New assets with low liquidity may result in failed swaps or may result in a user receiving less of the destination token due to slippage. An important responsibility of the token creator is to communicate to the community these risks. ","version":"Next","tagName":"h3"},{"title":"The Dokodemo Protocol","type":0,"sectionRef":"#","url":"/docs/the-dokodemo-protocol","content":"","keywords":"Funki Ethereum L2 Atherlabs decentralization cryptoeconomy blockchain decentralized apps dokodemo protocol nft","version":"Next"},{"title":"Meet the Dokodemo Protocol: Your NFT's Magical Door to Fun on Funki Chain​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#meet-the-dokodemo-protocol-your-nfts-magical-door-to-fun-on-funki-chain","content":" The Dokodemo Protocol is a game-changer in the Funki Chain universe, flipping the script on how we play with digital assets, namely Non-Fungible Tokens (NFTs). Think of it as the magic door from &quot;Doraemon,&quot; but for your NFTs, letting them zip around to different digital playgrounds while still connecting back their original authentic self, no multiverse collapse imminent!  ","version":"Next","tagName":"h3"},{"title":"What's the Dokodemo Protocol All About?​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#whats-the-dokodemo-protocol-all-about","content":" Basically, the Dokodemo Protocol lets your NFTs have a blast across various fun-filled digital environments without losing their cool, value (or key!). It's like having the superpower to be in multiple places at once, making sure your digital treasures can party everywhere but still safe at home.  ","version":"Next","tagName":"h3"},{"title":"Cool Features of the Dokodemo Protocol​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#cool-features-of-the-dokodemo-protocol","content":" Multiverse Mingle: NFTs can show up in different forms across various games and platforms within Funki Chain. They’re always connected back to the original, so no matter where they go, they remember where they came from.Play Nice With Others: This protocol is all about making friends! It helps your NFTs play smoothly with others by ensuring they can hop between different blockchain playgrounds without a hitch.Keepin' It Real (and Paid!): Go on and spread your NFTs far and wide—Dokodemo keeps tabs on the rights and royalties, making sure creators get their fair share, no matter where their creations end up.Who Did What Now?: Thanks to blockchain magic, tracking the history and adventures of your NFTs is a breeze. It’s all about keeping things clear and legit, so everyone knows who owns what and what’s been going down.More Fun for Everyone: By letting users see their NFTs in new lights and new fights, engagement goes through the roof. It’s a whole new way to bond with your digital buddies.  ","version":"Next","tagName":"h3"},{"title":"Why It's a Big Deal​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#why-its-a-big-deal","content":" Dokodemo shakes things up by making NFTs more than just digital veblen dust collectors. They become dynamic adventurers that gain value and stories as they explore new realms. This not only makes each NFT more interesting and valuable but also cranks up the fun factor by a ton.  Imagine your favorite digital character not just stuck in one game but leveling up in multiple arenas, carrying its victories, loot, and tales from one world to another. It’s like giving your digital pal a life that’s richer than ever, stuffed with interactions that make every NFT uniquely yours.  ","version":"Next","tagName":"h3"},{"title":"But you’re in it for “teh tech”?​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#but-youre-in-it-for-teh-tech","content":" At Dokodemo Protocol’s heart, Funki Chain utilizes the &quot;Fun Feed&quot; from various integrated entertainment blockchains, employing Innovative Protocol Compilers (IPCs) to create and evolve unique and engaging Non-Fungible Tokens (NFTs) with dynamic states. These states trigger diverse actions in a similar manner to game logic, enabling unprecedented composability and expandability through rich, interactive entertainment experiences.  ","version":"Next","tagName":"h3"},{"title":"The Fun Feed​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#the-fun-feed","content":" The Fun Feed is a core element of Funki Chain, acting as a channel for real-time onchain data from various blockchain networks. This data spans item generation, item states, user achievements, game assets, virtual world social interactions, and more, all unified under Funki Chain in a 'farcaster-like' manner.  By aggregating and maintaining this data, Funki Chain enables the development of rich applications that are both expansive and cross-chain interoperable in the future.  ","version":"Next","tagName":"h3"},{"title":"The Fun Finders​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#the-fun-finders","content":" Data Oracles are called Fun Finders and act as tools that fetch, verify, and relay data from external blockchains to Funki Chain's ecosystem. This data, crucial for the creation and evolution of NFTs and the activation of Fun Masters, includes user achievements, in-game transactions, and other relevant entertainment metrics. Ensuring the accuracy and timeliness of this data is paramount for the integrity of Funki Chain's ecosystem and the value of its NFT assets.  ","version":"Next","tagName":"h3"},{"title":"The States of Fun​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#the-states-of-fun","content":" Inspired by &quot;The Diamond Age,&quot; Protocol Compilers in Funki Chain are smart contracts capable of transforming the data extracted from Fun Oracles, through the Fun Feed into tangible source of truth NFT data states.  These digital PCs receive, synthesize, and compile information, assets, and user on-chain interactions within Funki Chain, to craft, expand, and program NFTs, triggering smart contracts that are rich in information and deeply connected to the entertainment worlds they originate from.  ","version":"Next","tagName":"h3"},{"title":"Fun Masters​","type":1,"pageTitle":"The Dokodemo Protocol","url":"/docs/the-dokodemo-protocol#fun-masters","content":" The Fun Masters represent Funki Chain's innovative approach to decentralized contribution &amp; governance. As a distributed network of enthusiastic users, the Fun Masters contribute their time, creativity, and entertainment insights to enrich and verify the authenticity of the digital assets within Funki Chain.  Through this collaborative effort, the states of NFTs can be updated, enhanced, challenged, and made more complex, driven by a system of incentivized rewards, ensuring a vibrant and evolving digital asset ecosystem, akin to a decentralized, interactive funhouse. ","version":"Next","tagName":"h3"},{"title":"Security","type":0,"sectionRef":"#","url":"/docs/security","content":"","keywords":"Funki bug bounty program report vulnerability bug report cybersecurity HackerOne Funki network Bedrock Optimism vulnerability reporting crypto security open source","version":"Next"},{"title":"Security Model​","type":1,"pageTitle":"Security","url":"/docs/security#security-model","content":" Funki is an OP Stack L2 and a key part of Optimism Superchain. Funki runs the OP Stack mainnet configuration in partnership with Optimism.  In return for ongoing technical and product support from Optimism, Funki contributes sequencer fees, and research and innovation to the OP Collective.    ","version":"Next","tagName":"h2"},{"title":"Mainnet Multisig​","type":1,"pageTitle":"Security","url":"/docs/security#mainnet-multisig","content":" The security of Funki L2 is currently dependent on a multisig managed jointly by the Funki Security Council, the Optimism Security Council and the Optimism Foundation.  This multisig can be used to upgrade core Funki L2 smart contracts without upgrade delays to allow for quick responses to potential security concerns. All upgrades to the system must be approved by both component multisigs and either can veto an upgrade.    ","version":"Next","tagName":"h2"},{"title":"Bugs and Unknowns​","type":1,"pageTitle":"Security","url":"/docs/security#bugs-and-unknowns","content":" The OP Stack has been audited on many occasions, but audits are not a stamp of approval and a completed audit does not mean that the audited codebase is free of bugs.  It's important to understand that using Funki inherently exposes you to the risk of bugs within the codebase, and that you use Funki Mainnet at your own risk.  ","version":"Next","tagName":"h2"},{"title":"OPTIMISM 's BUG BOUNTY PROGRAM​","type":1,"pageTitle":"Security","url":"/docs/security#optimism-s-bug-bounty-program","content":" https://docs.optimism.io/chain/security/security-policy ","version":"Next","tagName":"h2"},{"title":"Block Explorers","type":0,"sectionRef":"#","url":"/docs/tools/block-explorers","content":"","keywords":"block explorers Funki block explorer Funki block explorers Funki blockchain Funki network Funki mainnet Funki testnet smart contract analysis transaction tracking transaction details Blockscout Etherscan Funkiscan","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Block Explorers","url":"/docs/tools/block-explorers#mainnet","content":" A Routescan explorer is available for Funki Mainnet.  Routescan superchain explorer allows you to search for transactions, addresses, tokens, prices and other activities taking place across all Superchain blockchains, including Funki.    ","version":"Next","tagName":"h2"},{"title":"Testnet​","type":1,"pageTitle":"Block Explorers","url":"/docs/tools/block-explorers#testnet","content":" A Blockscout explorer is available for Funki Testnet.  Blockscout provides tools to help you debug smart contracts and transactions:  View, verify, and interact with smart contract source code.View detailed transaction information   ","version":"Next","tagName":"h2"},{"title":"Contract Addresses","type":0,"sectionRef":"#","url":"/docs/funki-contracts","content":"","keywords":"Funki Funki network contracts Funki contracts L2 contract addresses Funki contract addresses smart contracts Funki smart contracts Funki Mainnet Funki Testnet","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#mainnet","content":" ","version":"Next","tagName":"h2"},{"title":"Ethereum (L1)​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#ethereum-l1","content":" Name\tAddressAddressManager\t0x5a4ebF927338EA6af377caEee99C85088908f57D AnchorStateRegistryProxy\t0x48eB5A81CC3a8955d0DabD6eEd45ac09C7c1889f BatchInboxAddress\t0xFF00000000000000000000000000000084bb84bb DataAvailabilityChallengeProxy\t0xF40b807c2407e1d7dabb85f3ceefd5EACc7bF3CD DelayedWETHProxy\t0x7992352f723d1209CDd9B786dEF1fBd8DC6511DB DisputeGameFactoryProxy\t0x2Dc9d2Cb1Ba0b8A46AE252ab4FBE1ad5C5c3B795 L1CrossDomainMessengerProxy\t0x8F56a665c376A08b604DD32ee6E88667A6093172 L1ERC721BridgeProxy\t0x94519dD4BA8ba20Aaad14f7C6cD00fa1bB0192E9 L1StandardBridgeProxy\t0xA2C1C1A473250094a6244F2bcf6Cb51F670Ad3aC L2OutputOracleProxy\t0x1A9aE6486caEc0504657351ac473B3dF8A1367cb Mips\t0x29564D1B96A1308E6930F88665576763Ed4837E2 OptimismMintableERC20FactoryProxy\t0x87e75DcC1BB4e5B42cB5c52eB5832d6eCC3bFeF4 OptimismPortalProxy\t0x5C9C7f98eD153a2deAA981eB5C97B31744AccF22 PreimageOracle\t0xd8f66eFeC53CeA76C597827ba5Bf3F68D29f2fA8 ProtocolVersionsProxy\t0x4e963F3335Bb44d03302A2C9f3c254F74d15cEBA ProxyAdmin\t0xD069C4724f9bC15FA53b3b2516594512AEf8c957 SafeProxyFactory\t0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 SafeSingleton\t0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552 SuperchainConfigProxy\t0xD3B2Ee457Cf8F05f00c17BFe509b43BA04c9e5a2 SystemConfigProxy\t0xD39a6CcCFa23cb741bB530497e42EC337f1215a8 SystemOwnerSafe\t0x89CB6669f87c165E7128F4a57476EE4Daa7ffbCD  ","version":"Next","tagName":"h3"},{"title":"Funki (L2)​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#funki-l2","content":" Name\tAddressWETH9\t0x4200000000000000000000000000000000000006 L2CrossDomainMessenger\t0x4200000000000000000000000000000000000007 L2StandardBridge\t0x4200000000000000000000000000000000000010 SequencerFeeVault\t0x4200000000000000000000000000000000000011 OptimismMintableERC20Factory\t0x4200000000000000000000000000000000000012 GasPriceOracle\t0x420000000000000000000000000000000000000F L1Block\t0x4200000000000000000000000000000000000015 L2ToL1MessagePasser\t0x4200000000000000000000000000000000000016 L2ERC721Bridge\t0x4200000000000000000000000000000000000014 OptimismMintableERC721Factory\t0x4200000000000000000000000000000000000017 ProxyAdmin\t0x4200000000000000000000000000000000000018 BaseFeeVault\t0x4200000000000000000000000000000000000019 L1FeeVault\t0x420000000000000000000000000000000000001a EAS\t0x4200000000000000000000000000000000000021 EASSchemaRegistry\t0x4200000000000000000000000000000000000020  ","version":"Next","tagName":"h3"},{"title":"Testnet (Sepolia)​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#testnet-sepolia","content":" ","version":"Next","tagName":"h2"},{"title":"Sepolia (L1)​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#sepolia-l1","content":" Name\tAddressAddressManager\t0x6ECc4a306cD20f8041d63B3Db8ecA46b713cDEcC AnchorStateRegistryProxy BatchInboxAddress\t0xFF000000000000000000000000000000000084bb DataAvailabilityChallengeProxy\t0x12C6A7dB25b20347CA6F5d47E56D5E8219871C6d DelayedWETHProxy\t0x31D0D1D3Fc27B3f174E544364e7Bb836980162d1 DisputeGameFactoryProxy\t0xEc7C6E35f4e5361D279d5Fe7222F3F45A8A83352 L1CrossDomainMessengerProxy\t0x6F82D895E223Dde65DA28a8bbD14f3eF79cBF3b8 L1ERC721BridgeProxy\t0x598D245Ea85FBfBceCe6c62232bbCAB688D3F68b L1StandardBridgeProxy\t0x1ba82f688eF3C5B4363Ff667254ed4DC59E97477 L2OutputOracleProxy\t0xB25812386D1Cb976b50de7387F5CBc10Fec3F27c Mips\t0x71483031c5D2927Ea83807d5C88bd8EccFaF292d OptimismMintableERC20FactoryProxy\t0x8eE8eB6B829C382cA395D35C40Dcd2ef8AE57c68 OptimismPortalProxy\t0xCeE7ef4dDF482447FE14c605Ea94B37cBE87Ca9D PreimageOracle\t0x2DE051316aaD761A3eBd6fF008D714805bD02c56 ProtocolVersionsProxy\t0x1a9B6775ffc5EfEEe6Abbe9C29512dAeE52F118B ProxyAdmin\t0xB3E1F3ab2A22049Cc155ebA7089Ea20A5EAB99ca SafeProxyFactory\t0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 SafeSingleton\t0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552 SuperchainConfigProxy\t0x00df2E8EfbE6ad2538D940a2cCAAE65112bd0437 SystemConfigProxy\t0xd6A01f1Ef51D65F023433992a8F62fEeAD35b172 SystemOwnerSafe\t0x814973b1ec9Eb9172996931dE7BF1380bd64a824  ","version":"Next","tagName":"h3"},{"title":"Funki Sepolia (L2)​","type":1,"pageTitle":"Contract Addresses","url":"/docs/funki-contracts#funki-sepolia-l2","content":" Name\tAddressWETH9\t0x4200000000000000000000000000000000000006 L2CrossDomainMessenger\t0x4200000000000000000000000000000000000007 L2StandardBridge\t0x4200000000000000000000000000000000000010 SequencerFeeVault\t0x4200000000000000000000000000000000000011 OptimismMintableERC20Factory\t0x4200000000000000000000000000000000000012 GasPriceOracle\t0x420000000000000000000000000000000000000F L1Block\t0x4200000000000000000000000000000000000015 L2ToL1MessagePasser\t0x4200000000000000000000000000000000000016 L2ERC721Bridge\t0x4200000000000000000000000000000000000014 OptimismMintableERC721Factory\t0x4200000000000000000000000000000000000017 ProxyAdmin\t0x4200000000000000000000000000000000000018 BaseFeeVault\t0x4200000000000000000000000000000000000019 L1FeeVault\t0x420000000000000000000000000000000000001a EAS\t0x4200000000000000000000000000000000000021 EASSchemaRegistry\t0x4200000000000000000000000000000000000020 ","version":"Next","tagName":"h3"},{"title":"FUNKI PRIVACY POLICY","type":0,"sectionRef":"#","url":"/docs/privacy-policy","content":"FUNKI PRIVACY POLICY Last Updated: April 15, 2024 The GIN Management Company Limited (&quot;FUNKI,&quot; &quot;we,&quot; &quot;us,&quot; or &quot;our&quot;) is a company incorporated under the laws of the British Virgin Islands. We value your privacy and are dedicated to maintaining the confidentiality and security of your personal information. This Privacy Policy outlines our practices regarding the collection, use, disclosure, and protection of personal information that may be gathered when you engage with our blockchain-related services, including but not limited to the FUNKI Protocol, FUNKI Gateway Interface, FUNKI NFT Service, and FUNKI Marketplace (together referred to as the &quot;Services&quot;), in accordance with the British Virgin Islands Data Protection Regulations, and, in respect of any EU data subjects, the EU General Data Protection Regulation. We urge you to read this Privacy Policy in its entirety to gain a comprehensive understanding of how we handle your personal information in connection with our Services. By accessing or utilizing the Services, you are consenting to the practices and procedures described in this Privacy Policy. If, for any reason, you do not consent to the collection, use, and disclosure of your information as delineated herein, you should refrain from accessing or using the Services. This Privacy Policy applies to information we collect through the Services, in email, text, and other electronic messages between you and the Services, and when you interact with our advertising and applications on third-party websites and services if those applications or advertising include links to this policy. It does not apply to information collected by us offline or through any other means, including on any other website operated by any third party, or by any third party, including through any application or content that may link to or be accessible from or on the Services. This Privacy Policy is subject to change. We reserve the right to update and revise it at our discretion. We will post any changes to the Privacy Policy on this page, along with a notice at the top of the page indicating when the last revisions were made. Your continued use of our Services after any modification to the Privacy Policy will constitute your acceptance of such modification. We encourage you to review the Privacy Policy whenever you access the Services to stay informed about our information practices and the ways you can help protect your privacy. 1. INFORMATION WE COLLECT In the course of providing the Services, GIN Management Company Limited may collect and process various categories of information from and about users. This information enables us to deliver, personalize, and improve our Services. The types of information we may collect include, but are not limited to, the following: Personal Information: This refers to information that can be used to identify you as an individual. When you register for an account, engage in transactions, or access certain - - - functionalities of the Services, we may collect personal identifiers such as your name, postal address, email address, telephone number, government identification number, and digital wallet addresses. Additionally, we may collect other related information that you voluntarily provide, such as your date of birth, transaction history, and payment details.Usage Data: As you navigate through and interact with our Services, we may automatically collect data about your equipment, browsing actions, and usage patterns. This data may include information such as your Internet Protocol (IP) address, log files, web beacons, cookies, and other tracking technologies, device type, browser type, browser language, operating system, the pages or features of our Services that you browse and the time spent on those pages or features, the frequency with which you use the Services, the links you click on or use, and other statistics.Information from Third Parties: We may receive information about you from third-party sources, such as blockchain analysis services, credit bureaus, identity verification services, and publicly available databases. This information may include additional personal information or details about your blockchain transactions that we combine with the information we have collected directly from you.Please note that we may also collect, use, and share aggregated data such as statistical or demographic data for various purposes. Aggregated data may be derived 2. HOW WE USE YOUR INFORMATION The information we collect serves as a cornerstone for delivering and enhancing the Services we offer. FUNKI uses the information gathered from our users in a variety of ways, including but not limited to the following: To Provide and Manage the Services: We use your information to operate, provide, maintain, and manage the Services you have requested or authorized. This includes using your information to facilitate the creation and security of your account, to process your transactions, to provide customer support, and to ensure the overall smooth operation of the Services.To Communicate with You: We utilize your information to communicate with you regarding your account or transactions, to inform you about changes to our terms, conditions, and policies, and to send you alerts and other administrative messages. We may also use your information to respond to your comments, questions, and requests, provide customer service and support, and send you technical notices, updates, security alerts, and administrative messages.For Marketing and Promotional Purposes: Your information allows us to provide you with news and information about products, services, offers, promotions, rewards, and events we believe may be of interest to you. We may also use your information to send you newsletters, marketing or promotional materials, and other information that may be of interest to you. You may opt out of receiving any, or all, of these communications from us by following the unsubscribe link or instructions provided in any email we send.To Personalize User Experience: We use your information to personalize the Services and to provide content, features, and advertisements tailored to your interests and preferences. This includes using your information to help us understand your preferences based on previous or current activity on the Services, which enables us to provide you with improved services.For Research and Analytics: To better understand how users access and use our Services, both on an aggregated and individualized basis, we use your information to monitor and analyze trends, usage, and activities in connection with our Services. This helps us improve our Services and develop new products, services, and features.To Ensure Security and Integrity: We use your information to detect, investigate, and prevent fraudulent transactions, abuse, security breaches, and other illegal activities and to protect the rights and property of FUNKI and others.To Enforce Our Policies and Terms: We use your information to enforce our Terms of Service, including to protect our intellectual property rights. For Contests and Promotions: We may use your information to facilitate contests, sweepstakes, and promotions, and to process and deliver entries and rewards.To Combine Information: We may link or combine information we collect from or about you with other information we obtain from third parties or information we already hold to help understand your needs and provide you with better service.For Other Purposes: We may also use your information for other purposes described to you at the time the information was collected or as otherwise set forth in this Privacy Policy. We will only use your personal information for the purposes for which we collected it, unless we reasonably consider that we need to use it for another reason and that reason is compatible with the oriFUNKIal purpose. 3. SHARING OF YOUR INFORMATION FUNKI recognizes the importance of safeguarding your personal information and restricts the sharing of your details to specific circumstances and with particular third parties, as outlined below: Service Providers: We may share your information with third-party service providers, contractors, and agents who perform services for us or on our behalf, such as payment processing, data analysis, email delivery, hosting services, customer service, and marketing assistance. These service providers are given access to your information as is reasonably necessary to perform these tasks on our behalf and are obligated not to disclose or use it for other purposes.Business Transfers: In the event that FUNKI is involved in a merger, acquisition, divestiture, restructuring, reorganization, dissolution, or other sale or transfer of some or all of FUNKI's assets, whether as a going concern or as part of bankruptcy, liquidation, or similar proceeding, your personal information may be transferred to the buyer or other successor entity.Legal Obligations and Rights: We may disclose your information if we believe it is necessary to comply with a legal obligation, such as responding to a subpoena, court order, or other governmental request, or when we believe in good faith that disclosure is necessary to protect our rights, protect your safety or the safety of others, investigate fraud, or respond to a government request.Protection of Rights: We may also share your information to enforce our terms and conditions, to protect the security or integrity of our Services, and to protect the property, legal rights, or safety of FUNKI, our users, or others, as permitted or required by law.With Consent: We may disclose your personal information to any other third party with your prior consent to do so. This may include sharing information with other parties for their own marketing purposes as permitted by law.Blockchain Analysis Providers: To ensure compliance with legal, regulatory, and law enforcement requirements, we may share your information with blockchain analysis providers. This is to monitor and analyze blockchain transactions and to prevent prohibited conduct, such as fraudulent activities and money laundering. Aggregated or Anonymized Data: We may share aggregated or anonymized information that does not directly identify you with third parties for research, marketing, analytics, and other purposes. Please note that the Services may include links to third-party websites, plug-ins, services, social networks, or applications. Clicking on those links or enabling those connections may allow third parties to collect or share data about you. We do not control these third-party websites and are not responsible for their privacy statements. When you leave our Services, we encourage you to read the privacy policy of every website you visit. We may also share your personal information with other third parties when you explicitly direct us to do so or when you use our Services to interact with third-party products or services. 4. DATA SECURITY FUNKI is committed to the protection of your personal information and has instituted a range of security measures aimed at safeguarding your data from accidental loss and from unauthorized access, use, alteration, and disclosure. These measures include, but are not limited to, encryption technologies, firewalls, and secure server facilities. Our security protocols are designed to protect the confidentiality, integrity, and availability of your personal information during storage, processing, and transmission. Despite our efforts to provide a secure and reliable environment for your personal information, it is important to acknowledge that no system of transmission over the Internet, or method of electronic storage, is 100% secure. Similarly, while the blockchain provides unique security features, it is not impervious to all security threats. Therefore, we cannot guarantee absolute security for your personal information transmitted to or through our Services, nor can we ensure or warrant the security of any information you transmit to us over the Internet, including the use of email. To further enhance data security, we also take measures to ensure that our service providers who may have access to your personal information are contractually obligated to keep such information confidential and secure, and they are not permitted to use it for any purpose other than to carry out the services they are performing for FUNKI. We encourage you to take steps to protect against unauthorized access to your account and personal information by, among other things, choosing a robust password that nobody else knows or can easily guess and keeping your log-in and password private. We are not responsible for any lost, stolen, or compromised passwords, or for any activity on your account via unauthorized password activity. Please be aware that you play a vital role in protecting your own personal information. When registering with our Services, it is important to choose an account password of sufficient length and complexity, to not reveal this password to any third parties, and to immediately notify us if you become aware of any unauthorized access to or use of your account. In the unfortunate event that your personal information is compromised, we will notify you and any applicable regulator of a breach where we are legally required to do so. 5. YOUR CHOICES We acknowledge your right to control your personal information and provide you with choices regarding the collection, use, and sharing of your information: Account Information: You have the ability to review, update, correct, or delete your personal information at any time. To do so, simply log into your account on our Services and navigate to the account settings page, where you can make the desired changes to your account information. It is important to keep your personal information accurate and up-to-date, and we encourage you to review your information regularly to ensure that it reflects your current preferences and circumstances.Communication Preferences: If you no longer wish to receive promotional communications from us, you have the option to opt out by following the unsubscribe instructions provided in those communications. Please note that this opt-out does not apply to non-promotional communications, such as those about your account, transactions, servicing, or FUNKI's ongoing business relations.Cookies and Tracking Technologies: Cookies consist of small data files that may include an anonymous unique identifier. These files are sent to your browser from a website and stored on your device. In addition to cookies, we utilize various tracking technologies, including beacons, tags, and scripts, to collect and track information, thereby enhancing and analyzing Services. You have the option to instruct your browser to refuse all cookies or to notify you when a cookie is being sent. However, please note that if you do not accept cookies, you may not be able to utilize certain portions of the Services. Please be aware that if you choose to delete your information or opt out of the collection and use of your information, certain features and functionalities of the Services may no longer be available to you. We respect your privacy and give you an opportunity to opt out of receiving announcements of certain information. 6. CONTACT US Should you have any inquiries, concerns, or comments regarding this Privacy Policy, or if you need further assistance with respect to our privacy practices, please do not hesitate to reach out to us. You can contact GIN Management Company Limited by sending an email to legal@ginprotocol.com. We are dedicated to addressing your questions and concerns and will make every effort to respond to your requests in a timely and transparent manner. Your feedback is valuable to us as it helps us improve our privacy measures and the Services we offer. Please note that email communications are not always secure, so please do not include sensitive information in your emails to us. Your privacy is of utmost importance to us, and we are committed to protecting your personal information and respecting your choices concerning its use. We welcome the opportunity to discuss our privacy practices with you and to provide any additional information or clarification you may require.","keywords":"","version":"Next"},{"title":"Bridges","type":0,"sectionRef":"#","url":"/docs/tools/bridges/mainnet","content":"","keywords":"Funki Funki network bridging bridge to Funki bridge ETH bridge ETH to Funki Funki Bridge Ethereum Mainnet Funki Mainnet ETH ERC-20 tokens asset bridging","version":"Next"},{"title":"Funki Bridge​","type":1,"pageTitle":"Bridges","url":"/docs/tools/bridges/mainnet#funki-bridge","content":" The Funki Bridge allows you to bridge ETH and certain ERC-20s from Ethereum to Funki and vice versa.  To bridge to or from Funki:  Visit Funki BridgeClick Connect walletConnect your walletChoose the amount of ETH (or the asset of your choice that's available) you'd like to deposit or withdraw  For frequently asked questions about Funki Bridge, be sure to check out the Bridge FAQ.    caution Double check the token address for ERC-20s You can use any ERC-20 that is supported on the network. You can check what assets are on Funki and the corresponding contract address via this hub. Always test with small amounts to ensure the system is working as expected.  caution This implementation only can bridge assets to Funki. Do not attempt to alter the code to withdraw the assets.   ","version":"Next","tagName":"h2"},{"title":"Funki Bridge - FAQ","type":0,"sectionRef":"#","url":"/docs/tools/bridges/funki-bridges-faq","content":"","keywords":"Funki Bridge FAQ frequently asked questions bridging to Funki how to bridge to Funki Ethereum blockchain technology digital asset transfer cryptocurrency wallet compatibility transaction security network fees","version":"Next"},{"title":"1. What is Funki Native Bridge​","type":1,"pageTitle":"Funki Bridge - FAQ","url":"/docs/tools/bridges/funki-bridges-faq#1-what-is-funki-native-bridge","content":" Funki Native Bridge is only available for bridging SIPHER, USDT, ETH from Ethereum mainnet to Funki Chain.Native bridge is a great option for moving larger token amounts. But when moving small amounts, the gas costs for the transactions can sometimes add up, making it too expensive. For bridging smaller amounts we recommend choosing a different route, either Relay or Superbridge if available.When using Native Bridge, a minimum 7-day challenge period is required to withdraw funds to Ethereum.  Here’s some of the benefits of using the Native Bridge  You get the canonical, native asset on the destination chain.There are no extra fees imposedIt’s generally the most secure form of bridging, because by using the Native Bridge you have the same trust assumptions as using the rollup itself  ","version":"Next","tagName":"h3"},{"title":"2. Native Bridge Fees & charges​","type":1,"pageTitle":"Funki Bridge - FAQ","url":"/docs/tools/bridges/funki-bridges-faq#2-native-bridge-fees--charges","content":" We do not add extra fees for Native Bridge.However, normal network fees (gas fees) still apply.  Please note:  Bridging from Ethereum mainnet to a Settlement Chain (like Funki) requires multiple transactions. So network fees can add up. When bridging smaller amounts, it might be worth considering an alternate bridge route to save on network fees.  ","version":"Next","tagName":"h3"},{"title":"3. How to bridge assets from Ethereum mainnet to Funki Chain on Funki Native Bridge (Deposit)​","type":1,"pageTitle":"Funki Bridge - FAQ","url":"/docs/tools/bridges/funki-bridges-faq#3-how-to-bridge-assets-from-ethereum-mainnet-to-funki-chain-on-funki-native-bridge-deposit","content":" Step 1 — Connect your wallet  Be sure your wallet supports all Chains &amp; Funki Chain mainnet you will be bridging onto.    Add Funki Chain Mainnet to your Wallet  Network name: Funki MainnetNetwork RPC URL:  https://rpc-mainnet.funkichain.com  Chain ID: 33979Currency symbol: ETHBlock explorer URL:  https://funkiscan.io/      Step 2 — Select a token to bridge  Select the token you wish to bridge, and enter the amount.  Funki Native Bridge is only available for bridging SIPHER, USDT, ETH from Ethereum mainnet to Funki Chain.    Step 3 — Review your bridge  Tap the Review Bridge button and review your bridge details.  Please note the approximate transaction cost, and bridging time.    To proceed check the boxes indicating you understand the following:  The approximate time that the bridge will take.That the indicated network fees for each step are approximate and are subject to change depending on network activity.That you cannot cancel or reverse a bridge once it has been started.Step 4 — Start your bridge  Depending on the token, you may need to approve it first. This is so the bridge contract can use your funds for bridging. Note that we only request an approval for the amount you're bridging, this helps secure your wallet in case the bridge contracts are compromised.  Next, start your bridge and continue with the transaction in your wallet.    Once the transaction is successful, all you need to do is wait a for approximately the indicated time and your tokens will arrive on the chain! Each Rollup differs in how long this takes, but generally we see these bridges clearing in 2 to 10 minutes.    You can view your bridge progress from the activity screen.    ","version":"Next","tagName":"h3"},{"title":"4. How to bridge assets from Funki Chain to Ethereum Mainnet on Funki Native Bridge (withdraw)​","type":1,"pageTitle":"Funki Bridge - FAQ","url":"/docs/tools/bridges/funki-bridges-faq#4-how-to-bridge-assets-from-funki-chain-to-ethereum-mainnet-on-funki-native-bridge-withdraw","content":" Bridging off assets from Funki to Ethereum Mainnet on Funki Native Bridge is a multi-step process and requires multiple transactions. There is also a significant wait period (usually 7 days).Please note: Native bridge is a great option for moving larger token amounts. But when moving small amounts, the gas costs for the transactions can sometimes add up, making it too expensive. For bridging smaller amounts we recommend choosing a different route, like Relay if available.  Step 1 — Connect your wallet  Be sure your wallet supports all Chains &amp; Funki Chain mainnet you will be bridging onto.    Add Funki Chain Mainnet to your Wallet  Network name: Funki MainnetNetwork RPC URL: https://rpc-mainnet.funkichain.comChain ID: 33979Currency symbol: ETHBlock explorer URL: https://funkiscan.io/      Step 2 — Select a token to bridge  Select the token you wish to bridge, and enter the amount.  Funki Native Bridge is only available for bridging SIPHER, USDT, ETH from Ethereum mainnet to Funki Chain and back.        Step 3 - Check the process in the Activity log Wait for the Challenge Period The Challenge Period is a security measure built into the Native Bridge contracts for Optimism and other L2s based on Optimism like Funki. You will need to wait for the designated period of time before continuing with your bridge. The Challenge Period usually takes 7 days. Please check this progress bar often. There are some stages need your action to execute. 1: Waiting Prove 2: Ready to Prove 3: Proved 4: Waiting Finalize 5: Finalized  ","version":"Next","tagName":"h3"},{"title":"5. Alternative bridges​","type":1,"pageTitle":"Funki Bridge - FAQ","url":"/docs/tools/bridges/funki-bridges-faq#5-alternative-bridges","content":" You can use Superbridge - a powered the Native Bridge contracts for official Superchain rollup blockchains to bridge assets from other L2s to FunkiOr you can use Relay - a instant, low-cost bridging and cross-chain execution to bridge ETH, USDT, $SIPHER from Ethereum mainnet and Solana &amp; other L2s to Funki  *** These are third-party service providers is for your convenience. Funki has no responsibility for their operation. DYOR ","version":"Next","tagName":"h3"},{"title":"The Funki Token List","type":0,"sectionRef":"#","url":"/docs/tokens/bridging-an-l1-token-to-funki","content":"","keywords":"Funki Token List ERC-20 tokens Ethereum Funki Mainnet Funki Bridge token bridging token submission Optimism Superchain token deployment add token to Funki","version":"Next"},{"title":"Adding your token to the list​","type":1,"pageTitle":"The Funki Token List","url":"/docs/tokens/bridging-an-l1-token-to-funki#adding-your-token-to-the-list","content":" The steps below explain how to get your token on the Funki Token List.  ","version":"Next","tagName":"h2"},{"title":"Step 1: Deploy your token on Funki​","type":1,"pageTitle":"The Funki Token List","url":"/docs/tokens/bridging-an-l1-token-to-funki#step-1-deploy-your-token-on-funki","content":" Select your preferred bridging framework and use it to deploy an ERC-20 for your token on Funki. We recommend you use the framework provided by Funki's standard bridge contracts, and furthermore deploy your token using the OptimismMintableERC20Factory. Deploying your token on Funki in this manner provides us with guarantees that will smooth the approval process. If you choose a different bridging framework, its interface must be compatible with that of the standard bridge, otherwise it may be difficult for us to support.  ","version":"Next","tagName":"h3"},{"title":"Step 2: Submit details for your token​","type":1,"pageTitle":"The Funki Token List","url":"/docs/tokens/bridging-an-l1-token-to-funki#step-2-submit-details-for-your-token","content":" Follow the instructions in the GitHub repository and submit a PR containing the required details for your token. You must specify in your token's data.json file a section for ‘funki-testnet' and/or 'funki-mainnet'. The change you need to submit is particularly simple if your token has already been added to the Optimism token list.  ","version":"Next","tagName":"h3"},{"title":"Step 3: Await final approval​","type":1,"pageTitle":"The Funki Token List","url":"/docs/tokens/bridging-an-l1-token-to-funki#step-3-await-final-approval","content":" Tokens approved in the Github repository are not necessarily listed on the Funki Bridge and are not guaranteed or automatic. Funki Bridge reviews are conducted manually by the Funki team. ","version":"Next","tagName":"h3"},{"title":"FUNKI TERMS OF USE","type":0,"sectionRef":"#","url":"/docs/terms-of-use","content":"","keywords":"","version":"Next"},{"title":"1. Introduction and Acceptance​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#1-introduction-and-acceptance","content":" GIN Management Company Limited (&quot;FUNKI&quot;, &quot;we&quot;, &quot;our&quot; or &quot;us&quot;) hereby offers you, the user, the opportunity to engage with our comprehensive array of blockchain-related services (collectively, the &quot;Services&quot;), which encompass the following components:  The FUNKI Protocol, which facilitates user engagement by providing a streamlined mechanism for processing transactions on the Ethereum network, enabling the exchange of data between the Ethereum blockchain and the FUNKI Mainnet, as well as offering a platform for interaction with an assortment of smart contract applications that are deployed on the FUNKI Mainnet.The FUNKI Gateway Interface, a sophisticated web-based portal designed to allow users to seamlessly connect a compatible non-custodial software wallet, herein referred to as a &quot;Web3 Wallet&quot;, which serves as a conduit for initiating transactions on the FUNKI Mainnet and for transferring digital assets across various blockchains, including Ethereum and FUNKI Mainnet, as well as interoperating with other blockchains through integrations with third-party bridge services.The FUNKI NFT Service, a specialized offering that enables qualified participants to mint non-fungible tokens, known as Replica NFTs, on the FUNKI Mainnet, complete with customizable attributes, herein referred to as &quot;Attributes&quot;. These Replica NFTs are indelibly associated with the user's wallet address and are designed to be transferrable, facilitating their utilization within decentralized applications that operate on the FUNKI Mainnet.The FUNKI Marketplace, an online platform engineered to facilitate the exchange of NFTs between buyers and sellers. While FUNKI acts as the host for the marketplace and manages the processing of payments, it is important to note that FUNKI does not assume the role of a contracting party in any agreements that may arise between users within the marketplace. Users are solely responsible for the payment of all taxes, as defined and imposed by any relevant governmental authority, in connection with their utilization of the platform. This includes, but is not limited to, any taxes levied on the acquisition, ownership, or transfer of NFTs.Connectivity options that allow for integration with select third-party services and decentralized applications (collectively referred to as &quot;Third-Party Services&quot; or &quot;Dapps&quot;), which are made accessible through the FUNKI Gateway Interface. It is imperative to acknowledge that the use of these Third-Party Services is governed by their own respective terms and conditions  YOUR DECISION TO ACCESS OR ENGAGE WITH ANY OF THE SERVICES SIGNIFIES YOUR UNEQUIVOCAL AGREEMENT TO BE BOUND BY THESE TERMS OF USE, INCLUSIVE OF ALL TERMS INCORPORATED HEREIN BY REFERENCE. SHOULD YOU FIND YOURSELF IN DISAGREEMENT WITH ANY PORTION OF THESE TERMS IN THEIR ENTIRETY, YOUR REMEDY IS TO REFRAIN FROM ACCESSING OR UTILIZING THE SERVICES.  Please be aware that FUNKI reserves the exclusive right to revise or modify these Terms at any time, in accordance with our sole discretion. In the event that we effectuate material alterations to these Terms, we will endeavor to provide you with advance notice prior to the activation of the new terms. Your continued access to or use of the Services subsequent to the implementation of any revisions signifies your consent to be governed by the Terms as modified.  ","version":"Next","tagName":"h3"},{"title":"2. Eligibility​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#2-eligibility","content":" To be granted access to or to make use of the Services, you must satisfy certain eligibility criteria. Specifically, you must have attained the age of majority, being at least 18 years of age, and you must possess the requisite legal capacity to enter into binding agreements, such as these Terms. Additionally, you must ensure that you are not designated as a Prohibited Person under any prevailing sanctions laws. It is your responsibility to ensure adherence to all applicable laws and regulations in the course of utilizing the Services. Your compliance with these legal requirements is not only expected but is also a condition precedent to your continued use of the Services.  FUNKI Marketplace Restricted Countries: Purchase of NFTs on FUNKI Marketplace is not authorized to residents or persons located in any of the following countries: China (Mainland), Iran, North Korea, Albania, Botswana, Barbados, Mauritius Island, Burkina Faso, Cambodia, Cayman Islands, Haiti, Jamaica, Jordania, Mali, Malta, Morocco, Myanmar, Nicaragua, Pakistan, Panama, Russia, Senegal, South Sudan, Syria, Turkey, Uganda, Yemen and Zimbabwe.  ","version":"Next","tagName":"h3"},{"title":"3. Disclaimers and Assumption of Risk​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#3-disclaimers-and-assumption-of-risk","content":" YOU EXPRESSLY ACKNOWLEDGE AND AGREE THAT YOUR ACCESS TO AND USE OF THE SERVICES IS AT YOUR SOLE RISK. THE SERVICES ARE PROVIDED ON AN &quot;AS IS&quot; AND &quot;AS AVAILABLE&quot; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED. TO THE FULLEST EXTENT PERMISSIBLE PURSUANT TO APPLICABLE LAW, FUNKI EXPRESSLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND ANY WARRANTIES ARISING OUT OF COURSE OF DEALING OR USAGE OF TRADE. FUNKI ASSUMES NO LIABILITY OR RESPONSIBILITY FOR ANY ERRORS, MISTAKES, OR INACCURACIES OF CONTENT, OR FOR ANY UNAUTHORIZED ACCESS TO OR USE OF OUR SECURE SERVERS AND/OR ANY AND ALL PERSONAL INFORMATION STORED THEREIN.  YOU UNDERSTAND THAT THE SERVICES, INCLUDING THE FUNKI PROTOCOL, THE FUNKI GATEWAY INTERFACE, THE FUNKI NFT SERVICE, AND THE FUNKI NFT MARKETPLACE, ARE INNOVATIVE AND EXPERIMENTAL IN NATURE. AS SUCH, THEY MAY BE SUBJECT TO INHERENT RISKS INCLUDING UNFORESEEN BUGS, SECURITY VULNERABILITIES, AND THE EVOLVING REGULATORY LANDSCAPE. FUNKI DOES NOT MAKE ANY REPRESENTATIONS OR WARRANTIES THAT THE SERVICES WILL BE UNINTERRUPTED, TIMELY, SECURE, OR FREE FROM ERRORS OR DEFECTS.  FUNKI MARKETPLACE DISCLAIMERS AND ASSUMPTION OF RISK: (A) YOU ACKNOWLEDGE THAT THE FUNKI MARKETPLACE IS AN EXPERIMENTAL AND DECENTRALIZED PLATFORM FACILITATING PEER-TO-PEER EXCHANGE OF NFTS BETWEEN BUYERS AND SELLERS, GOVERNED BY SMART CONTRACTS ON THE FUNKI MAINNET. (B) FUNKI DOES NOT HAVE CUSTODY OR CONTROL OVER THE NFTS LISTED ON THE MARKETPLACE OR THE DEPLOYED SMART CONTRACTS. OWNERSHIP RECORDS EXIST SOLELY ON THE FUNKI MAINNET BLOCKCHAIN. (C) YOU ASSUME ALL RISKS OF UTILIZING THE MARKETPLACE, INCLUDING VOLATILITY OF NFT PRICES TIED TO CRYPTOCURRENCY MARKETS, POTENTIAL UNDISCOVERED TECHNICAL VULNERABILITIES, AND THE EVOLVING REGULATORY LANDSCAPE FOR BLOCKCHAIN TECHNOLOGIES. (D) YOU BEAR FULL RESPONSIBILITY FOR VERIFYING THE AUTHENTICITY, LEGALITY, AND FUNCTIONALITY OF ANY NFTS, ACCOUNTS OR COLLECTIONS YOU INTERACT WITH ON THE MARKETPLACE, INCLUDING ENSURING COMPLIANCE WITH INTELLECTUAL PROPERTY LAWS AND SANCTIONS REGULATIONS.  BY UTILIZING THE SERVICES, YOU ACCEPT AND ASSUME ALL RISKS THAT MAY BE ASSOCIATED WITH YOUR ENGAGEMENT WITH BLOCKCHAIN TECHNOLOGY, DIGITAL ASSETS, AND SMART CONTRACTS, INCLUDING, BUT NOT LIMITED TO, THE RISKS OF FINANCIAL LOSS, TECHNICAL GLITCHES, COMPROMISED SECURITY MECHANISMS, AND POTENTIAL REGULATORY SCRUTINY. FURTHERMORE, YOU ACKNOWLEDGE THAT YOUR INTERACTION WITH ANY WEB3 WALLET IS SUBJECT TO THE TERMS AND CONDITIONS ESTABLISHED BY THE RESPECTIVE WALLET PROVIDER, AND THAT FUNKI DOES NOT EXERT ANY CONTROL OVER THE FUNKI MAINNET OR ANY OTHER BLOCKCHAIN NETWORK THAT YOU MAY INTERACT WITH THROUGH THE SERVICES.  ","version":"Next","tagName":"h3"},{"title":"4. Prohibited Activities​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#4-prohibited-activities","content":" In your use of the Services, you covenant and agree to abide by all applicable local, state, national, and international laws and regulations, and you shall not infringe upon the rights of others, including but not limited to intellectual property rights, privacy rights, and contractual rights. You are solely responsible for all acts and omissions that occur under your account or password, including the content of your transmissions through the Services. Without limiting the foregoing, you agree not to:  Engage in any activity that may disrupt, impair, or interfere with the proper working of the Services or which may inhibit other users' ability to enjoy the Services in any way.Utilize the Services in connection with any illegal or illicit activities, including but not limited to those that support money laundering, terrorism, or other activities that are prohibited under applicable law.Access the Services through any automated means, including but not limited to, robots, spiders, or scrapers, other than those provided or authorized by FUNKI.Use the Services from a country sanctioned by the government of the United States or to facilitate transactions involving individuals sanctioned by the government of the United States or located in sanctioned countries.Infringe upon or violate any third-party intellectual property rights, including copyrights, trademarks, publicity rights, or other proprietary rights. You must not upload, share, or sell any content that you do not have the rights to distribute.Evade, disable, or otherwise interfere with security-related features of the Services, including features that prevent or restrict the use or copying of any content or enforce limitations on the use of the Services or the content therein.Introduce or disseminate any software, virus, worm, Trojan horse, or other harmful or disruptive element to the Services, or otherwise interfere with the integrity of the Services.Publish, post, upload, distribute, or disseminate any content that is slanderous, defamatory, obscene, pornographic, abusive, harassing, illegal, or otherwise objectionable according to the standards of FUNKI.Conduct or forward surveys, contests, pyramid schemes, or chain letters, or post unsolicited advertising, promotional materials, or other forms of solicitation to other users.Promote or encourage any third party to carry out any prohibited activities as outlined in these Terms of Use.  ","version":"Next","tagName":"h3"},{"title":"5. Limitation of Liability​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#5-limitation-of-liability","content":" TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, FUNKI, INCLUDING ITS AFFILIATES, DIRECTORS, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, AND LICENSORS, SHALL NOT BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, OR ANY LOSS OF PROFITS OR REVENUES, WHETHER INCURRED DIRECTLY OR INDIRECTLY, OR ANY LOSS OF DATA, USE, GOODWILL, OR OTHER INTANGIBLE LOSSES, RESULTING FROM (A) YOUR ACCESS TO, USE OF, OR INABILITY TO ACCESS OR USE THE SERVICES; (B) ANY CONDUCT OR CONTENT OF ANY THIRD PARTY ON THE SERVICES, INCLUDING WITHOUT LIMITATION, ANY DEFAMATORY, OFFENSIVE, OR ILLEGAL CONDUCT OF OTHER USERS OR THIRD PARTIES; OR (C) UNAUTHORIZED ACCESS, USE, OR ALTERATION OF YOUR TRANSMISSIONS OR CONTENT.  THE FOREGOING LIMITATION OF LIABILITY SHALL APPLY TO THE FULLEST EXTENT PERMITTED BY LAW IN THE APPLICABLE JURISDICTION. THE LIMITATIONS OF THIS SUBSECTION SHALL APPLY TO ANY THEORY OF LIABILITY, WHETHER BASED ON WARRANTY, CONTRACT, STATUTE, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, AND WHETHER OR NOT FUNKI HAS BEEN INFORMED OF THE POSSIBILITY OF ANY SUCH DAMAGE, AND EVEN IF A REMEDY SET FORTH HEREIN IS FOUND TO HAVE FAILED ITS ESSENTIAL PURPOSE.  ","version":"Next","tagName":"h3"},{"title":"6. Indemnification​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#6-indemnification","content":" You agree to defend, indemnify, and hold harmless FUNKI, its affiliates, and their respective officers, employees, directors, agents, and successors from and against any and all claims, liabilities, damages, judgments, awards, losses, costs, expenses, or fees (including reasonable attorneys' fees) arising out of or relating to your violation of these Terms of Use or your use of the Services, including, but not limited to:  Your use of the Services;Your submission, posting, or transmission of any content through the Services that violates any third-party right, including without limitation any copyright, trademark, trade secret, or other intellectual property or proprietary right;Any other party's access and use of the Services with your unique username, password, or other appropriate security code;Any violations of these Terms related to your NFT listings or transactions on the Marketplace;Any disputes, misrepresentations or illegal conduct involving other users on the Marketplace;Any technical issues, vulnerabilities or failures associated with NFTs or smart contracts you listed or interacted with on the Marketplace;Your violation of any laws, rules, regulations, codes, statutes, ordinances, or orders of any governmental and quasi-governmental authorities, including, without limitation, all regulatory, administrative, and legislative authorities; orAny misrepresentation made by you.  You will cooperate as fully required by FUNKI in the defense of any claim. FUNKI reserves the right to assume the exclusive defense and control of any matter subject to indemnification by you, and you will not in any event settle any claim without the prior written consent of FUNKI. This indemnification obligation will survive the termination of these Terms and your use of the Services.  ","version":"Next","tagName":"h3"},{"title":"7. Intellectual Property Rights​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#7-intellectual-property-rights","content":" The Services, including the FUNKI Protocol, Gateway Interface, NFT Service, Marketplace, and all underlying technology, software, algorithms, user interfaces, graphics, logos, designs, text, images, and other content (&quot;FUNKI Content&quot;) are the proprietary property of FUNKI, its affiliates, partners, licensors, or other content providers. The compilation of all FUNKI Content is the exclusive property of FUNKI and is protected by intellectual property laws.  Limited License: The Terms grant you a limited, non-exclusive, non-transferable, and revocable license to access and use the Services strictly for your personal, non-commercial purposes. This license is subject to your full compliance with these Terms and does not include any right to: Sell, resell, or use commercially the Services or any Content;Collect and use any product listings, descriptions, or prices;Make derivative uses of the Services or any Content;Download (other than page caching), copy, or transmit any Content for the benefit of any third party;Use any data mining, robots, or similar data gathering and extraction tools. Ownership of NFTs and Associated Content: FUNKI does not claim ownership over any NFTs listed or sold through the FUNKI Marketplace. All rights associated with the NFTs, including rights to any underlying digital content or data linked to the NFTs, are retained by the respective rights holders, creators, or as specified in the NFT metadata and smart contracts deployed by third parties.License Grant to FUNKI: By listing or selling NFTs on the FUNKI Marketplace, you grant FUNKI a worldwide, non-exclusive, royalty-free license to use, copy, transmit, distribute, publicly display, and make derivative works of any content and metadata associated with your listed NFTs, solely for the purpose of operating, promoting, and improving the FUNKI Marketplace and Services.Third-Party Content: The FUNKI Marketplace may contain or interact with third-party content, applications, or services. FUNKI does not control and is not responsible for such third-party content. You are solely responsible for ensuring that your use of any third-party content complies with applicable intellectual property laws and the terms imposed by the respective third-party providers.Infringement Claims: FUNKI will respond promptly to any substantiated claims of intellectual property infringement related to content listed on the Marketplace in accordance with applicable laws. FUNKI reserves the right to hide, remove or disable any allegedly infringing NFT listings upon receiving a properly supported claim. If FUNKI receives a valid infringement notice, it may forward the notice to the user who listed the allegedly infringing content.  ","version":"Next","tagName":"h3"},{"title":"8. Dispute Resolution​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#8-dispute-resolution","content":" In the event of any dispute, controversy, or claim arising out of or in connection with these Terms, or the breach, termination, or invalidity thereof (collectively, &quot;Disputes&quot;), you and FUNKI agree to seek resolution exclusively through final and binding arbitration, rather than in court. The arbitration shall be conducted in accordance with the Arbitration Rules of the British Virgin Islands International Arbitration Centre (&quot;BVI IAC&quot;), which Rules are deemed to be incorporated by reference into this clause. The tribunal will consist of a single arbitrator to be appointed in accordance with the BVI IAC Rules. The place of arbitration shall be Road Town, Tortola, British Virgin Islands, unless both parties agree in writing to an alternative location. The language of the arbitration shall be English.  By agreeing to arbitration, you understand and agree that you are waiving your rights to maintain other available dispute resolution processes, such as a court action or administrative proceeding, to settle disputes. Furthermore, you agree to waive any right to a jury trial and the right to participate in any class action lawsuit or class-wide arbitration. Any arbitration under these Terms will take place on an individual basis; class arbitrations and class actions are not permitted, and by entering into these Terms, you are giving up the ability to participate in a class action.  The arbitrator's decision shall be final and binding and may be entered as a judgment in any court of competent jurisdiction. Notwithstanding the foregoing, FUNKI may seek and obtain injunctive relief in any jurisdiction in any court of competent jurisdiction.  ","version":"Next","tagName":"h3"},{"title":"9. Miscellaneous​","type":1,"pageTitle":"FUNKI TERMS OF USE","url":"/docs/terms-of-use#9-miscellaneous","content":" These Terms, including any legal notices and disclaimers contained on the Services, constitute the entire agreement between you and FUNKI concerning your use of the Services. These Terms supersede all prior agreements, understandings, negotiations, and discussions, whether oral or written, between the parties. No amendment or modification of these Terms will be effective unless in writing and signed by a duly authorized representative of FUNKI.  If any provision of these Terms is held by a court or other tribunal of competent jurisdiction to be invalid, illegal, or unenforceable for any reason, such provision shall be eliminated or limited to the minimum extent such that the remaining provisions of the Terms will continue in full force and effect. The failure of FUNKI to exercise or enforce any right or provision of these Terms shall not operate as a waiver of such right or provision.  FUNKI reserves the right, at its sole discretion, to modify, amend, or replace any part of these Terms at any time. It is your responsibility to check these Terms periodically for changes. Your continued use of or access to the Services following the posting of any changes to these Terms constitutes acceptance of those changes. FUNKI may also, in the future, offer new services and/or features through the Services (including the release of new tools and resources). Such new features and/or services shall be subject to the terms and conditions of these Terms.  If FUNKI makes changes that are deemed material, it will provide you with notice as appropriate under the circumstances, such as by displaying a prominent notice within the Services or by sending you an email. FUNKI will determine, in its sole discretion, what constitutes a material change.  Should you wish to receive further clarification regarding these Terms, or if you have any inquiries or concerns, please direct your correspondence to the following email address: legal@ginprotocol.com. Your outreach will be addressed in a timely and professional manner.  Please note that the email address provided herein is for legal inquiries related to the Terms of Use and should not be used for customer service-related issues or questions.  These Terms were last updated on April 15, 2024. Please review regularly to ensure you are aware of any changes. Your continued use of the Services after such updates will constitute acknowledgment and agreement of the modified Terms. ","version":"Next","tagName":"h3"},{"title":"Bridges","type":0,"sectionRef":"#","url":"/docs/tools/bridges/testnet","content":"","keywords":"Funki Funki network bridging bridge to Funki bridge ETH bridge ETH to Funki Funki Bridge Ethereum Sepolia Funki Sepolia ETH ERC-20 tokens Funki Testnet asset bridging","version":"Next"},{"title":"Funki Bridge (Testnet)​","type":1,"pageTitle":"Bridges","url":"/docs/tools/bridges/testnet#funki-bridge-testnet","content":" The Funki Bridge for testnet allows you to bridge ETH and certain ERC-20s from Ethereum Sepolia to Funki Sepolia and vice versa.  To bridge to or from Funki Sepolia:  Visit Funki BridgeClick Connect walletConnect your walletChoose the amount of ETH (or the asset of your choice that's available) you'd like to deposit or withdraw    caution Double check the token address for ERC-20s You can use any ERC-20 that is supported on the network. You can check what assets are on Funki Sepolia and the corresponding contract address via this hub. Always test with small amounts to ensure the system is working as expected.  caution This implementation only can bridge assets to Funki. Do not attempt to alter the code to withdraw the assets.   ","version":"Next","tagName":"h2"},{"title":"Network Faucets","type":0,"sectionRef":"#","url":"/docs/tools/network-faucets","content":"Network Faucets Coming soon","keywords":"network faucets Funki Sepolia testnet ETH Funki testnet Funki  Faucet Superchain Faucet Bware Labs Faucet QuickNode Faucet LearnWeb3 Faucet Ethereum Mainnet testnet resources","version":"Next"},{"title":"Onramps","type":0,"sectionRef":"#","url":"/docs/tools/onramps","content":"Onramps Coming soon","keywords":"fiat-to-crypto onramps crypto onramp onramps Funki Funki network cryptocurrency ETH on Funki payment gateway payments fiat to crypto fiat MoonPay Onramp","version":"Next"},{"title":"Funki DEX FAQ","type":0,"sectionRef":"#","url":"/docs/tools/dexs/funki-dex","content":"","keywords":"Funki DEX FAQ frequently asked questions decentralized exchange token swaps liquidity pools UniswapV3 cryptocurrency trading DeFi smart contracts security audits trading fees","version":"Next"},{"title":"What is Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#what-is-funki-dex","content":" Funki DEX is a decentralized exchange built on Funki blockchain, enabling users to swap tokens and provide liquidity. It's built as a clone of UniswapV3, incorporating its proven architecture and features.  ","version":"Next","tagName":"h3"},{"title":"How secure is Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#how-secure-is-funki-dex","content":" All smart contracts powering Funki DEX have been thoroughly audited by Verichains's website, a leading blockchain security firm. You can review the complete audit reports at Funki DEX audit reports.  ","version":"Next","tagName":"h3"},{"title":"How do I start trading on Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#how-do-i-start-trading-on-funki-dex","content":" Visit Funki DEX and connect your Ethereum-compatible wallet. Once connected, you can start swapping tokens or providing liquidity to pools.  ","version":"Next","tagName":"h3"},{"title":"What can I do on Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#what-can-i-do-on-funki-dex","content":" You can:  Swap various crypto tokensCreate new liquidity poolsProvide liquidity to existing poolsEarn fees from liquidity provisionSet range orders for automated trading  ","version":"Next","tagName":"h3"},{"title":"Are there any fees for using Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#are-there-any-fees-for-using-funki-dex","content":" Yes, there are trading fees that vary by pool (0.05%, 0.3%, or 1%). These fees are distributed to liquidity providers. You'll also need to pay network gas fees for transactions.  ","version":"Next","tagName":"h3"},{"title":"What wallets are compatible with Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#what-wallets-are-compatible-with-funki-dex","content":" You can use any Ethereum-compatible wallet such as MetaMask, Rainbow Wallet, or other popular Web3 wallets.  ","version":"Next","tagName":"h3"},{"title":"How do I provide liquidity on Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#how-do-i-provide-liquidity-on-funki-dex","content":" Connect your wallet, navigate to the &quot;Pool&quot; section, and select &quot;New Position.&quot; Choose your token pair, fee tier, and price range, then deposit your tokens to start earning fees.  ","version":"Next","tagName":"h3"},{"title":"What tokens can I trade on Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#what-tokens-can-i-trade-on-funki-dex","content":" You can trade any ERC-20 token that has been deployed on the Funki network. The most common pairs are typically with stable coins and native tokens.  ","version":"Next","tagName":"h3"},{"title":"Is Funki DEX suitable for beginners?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#is-funki-dex-suitable-for-beginners","content":" While the interface is user-friendly, it's recommended to understand basic concepts of DeFi, liquidity provision, and impermanent loss before trading or providing liquidity.  ","version":"Next","tagName":"h3"},{"title":"What are the benefits of using Funki DEX?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#what-are-the-benefits-of-using-funki-dex","content":" Lower transaction fees compared to Ethereum mainnetFast transaction processingNo custodial risks (you maintain control of your funds)Earn yields through liquidity provisionAccess to a wide range of trading pairs  ","version":"Next","tagName":"h3"},{"title":"How can I track my trading activity?​","type":1,"pageTitle":"Funki DEX FAQ","url":"/docs/tools/dexs/funki-dex#how-can-i-track-my-trading-activity","content":" You can view your trading history, active liquidity positions, and earnings directly through the Funki DEX interface under the &quot;Activity&quot; section. ","version":"Next","tagName":"h3"},{"title":"viem","type":0,"sectionRef":"#","url":"/docs/tools/clients/viem","content":"","keywords":"viem Funki Funki mainnet Funki testnet Ethereum smart contracts blockchain RPC URL JavaScript TypeScript","version":"Next"},{"title":"Install​","type":1,"pageTitle":"viem","url":"/docs/tools/clients/viem#install","content":" To install viem run the following command:  npm install --save viem   ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"viem","url":"/docs/tools/clients/viem#setup","content":" Before you can start using viem, you need to setup a Client with a desired Transport and Chain.  import { createPublicClient, http } from 'viem'; import { funki } from 'viem/chains'; const client = createPublicClient({ chain: funki, transport: http(), });   info To use Funki, you must specify funki as the chain when creating a Client. To use Funki Sepolia (testnet), replace funki with funkiSepolia.  ","version":"Next","tagName":"h2"},{"title":"Reading data from the blockchain​","type":1,"pageTitle":"viem","url":"/docs/tools/clients/viem#reading-data-from-the-blockchain","content":" Once you have created a client, you can use it to read and access data from Funki using Public Actions  Public Actions are client methods that map one-to-one with a &quot;public&quot; Ethereum RPC method (eth_blockNumber, eth_getBalance, etc.)  For example, you can use the getBlockNumber client method to get the latest block:  const blockNumber = await client.getBlockNumber();   ","version":"Next","tagName":"h2"},{"title":"Writing data to the blockchain​","type":1,"pageTitle":"viem","url":"/docs/tools/clients/viem#writing-data-to-the-blockchain","content":" In order to write data to Funki, you need to create a Wallet client (createWalletClient) and specify an Account to use.  import { createWalletClient, custom } from 'viem' import { funki } from 'viem/chains' const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' }) const client = createWalletClient({ account, chain: funki, transport: custom(window.ethereum) }) client.sendTransaction({ ... })   info In addition to making a JSON-RPC request (eth_requestAccounts) to get an Account, viem provides various helper methods for creating an Account, including: privateKeyToAccount, mnemonicToAccount, and hdKeyToAccount. To use Funki Sepolia (testnet), replace funki with funkiSepolia.  ","version":"Next","tagName":"h2"},{"title":"Interacting with smart contracts​","type":1,"pageTitle":"viem","url":"/docs/tools/clients/viem#interacting-with-smart-contracts","content":" You can use viem to interact with a smart contract on Funki by creating a Contract instance using getContract and passing it the contract ABI, contract address, and Public and/or Wallet Client:  import { getContract } from 'viem'; import { wagmiAbi } from './abi'; import { publicClient } from './client'; // 1. Create contract instance const contract = getContract({ address: 'CONTRACT_ADDRESS', abi: wagmiAbi, publicClient, }); // 2. Call contract methods, listen to events, etc. const result = await contract.read.totalSupply();   info CONTRACT_ADDRESS is the address of the deployed contract. ","version":"Next","tagName":"h2"},{"title":"Cross-chain","type":0,"sectionRef":"#","url":"/docs/tools/cross-chain","content":"Cross-chain Coming soon","keywords":"cross-chain cross chain crosschain messaging cross-chain messaging omnichain omni-chain superchain Chainlink CCIP CCIP LayerZero Axelar Crossmint Wormhole web3 transactions blockchain communication Funki Mainnet Funki Testnet interchain connectivity blockchain interoperability cross-chain transactions cross-chain payments","version":"Next"},{"title":"Node Providers","type":0,"sectionRef":"#","url":"/docs/tools/node-providers","content":"Node Providers Coming soon","keywords":"Node Providers Funki Funki network Funki node hosted nodes archival nodes RPC RPC node RPC URL RPC endpoints blockchain services blockchain infrastructure developer tools API mainnet testnet pricing plans Web3 infrastructure","version":"Next"},{"title":"Foundry","type":0,"sectionRef":"#","url":"/docs/tools/toolchains/foundry","content":"","keywords":"Foundry Forge Foundry Book smart contract development toolchain Funki Funki mainnet Funki testnet Funki network RPC URL chain id deploying contracts verifying contracts mainnet testnet","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#mainnet","content":" ","version":"Next","tagName":"h2"},{"title":"Deploying a smart contract​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#deploying-a-smart-contract","content":" forge create ... --rpc-url=`https://rpc-mainnet.funkichain.com`/   ","version":"Next","tagName":"h3"},{"title":"Verifying a smart contract​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#verifying-a-smart-contract","content":" forge verify-contract ... --chain-id 33979   ","version":"Next","tagName":"h3"},{"title":"Testnet​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#testnet","content":" ","version":"Next","tagName":"h2"},{"title":"Deploying a smart contract​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#deploying-a-smart-contract-1","content":" forge create ... --rpc-url=https://funki-testnet.alt.technology   ","version":"Next","tagName":"h3"},{"title":"Verifying a smart contract​","type":1,"pageTitle":"Foundry","url":"/docs/tools/toolchains/foundry#verifying-a-smart-contract-1","content":" forge verify-contract ... --chain-id 3397901  ","version":"Next","tagName":"h3"},{"title":"Hardhat","type":0,"sectionRef":"#","url":"/docs/tools/toolchains/hardhat","content":"Hardhat Hardhat is an Ethereum development environment for flexible, extensible, and fast smart contract development. You can use Hardhat to edit, compile, debug, and deploy your smart contracts to Funki. Using Hardhat with Funki To configure Hardhat to deploy smart contracts to Funki, update your project’s hardhat.config.ts file by adding Funki as a network: networks: { // for mainnet &quot;funki-mainnet&quot;: { url: 'https://rpc-mainnet.funkichain.com', accounts: [process.env.PRIVATE_KEY as string], gasPrice: 1000000000, }, // for Sepolia testnet &quot;funki-sepolia&quot;: { url: &quot;https://sepolia-sandbox.funkichain.com/&quot;, accounts: [process.env.PRIVATE_KEY as string] gasPrice: 1000000000, }, // for local dev environment &quot;funki-local&quot;: { url: &quot;http://localhost:8545&quot;, accounts: [process.env.PRIVATE_KEY as string], gasPrice: 1000000000, }, }, defaultNetwork: &quot;funki-local&quot;, ","keywords":"Hardhat Funki Funki network Funki mainnet Funki testnet hardhat config hardhat configuration Ethereum development smart contract deployment mainnet testnet local development","version":"Next"},{"title":"Funki DEX-FAQ","type":0,"sectionRef":"#","url":"/docs/tools/dexs/funki-dex-faq","content":"","keywords":"Funki DEX FAQ frequently asked questions decentralized exchange token swaps liquidity pools UniswapV3 cryptocurrency trading DeFi smart contracts security audits trading fees","version":"Next"},{"title":"General​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#general","content":" ","version":"Next","tagName":"h2"},{"title":"1. What is FUNKI Swap?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#1-what-is-funki-swap","content":" FUNKI Swap is a new permissionless, open source (GPL), auction-based protocol for trading across AMMs and other liquidity sources. FUNKI Swap is built based on Uniswap protocol.  FUNKI Swap is available on FUNKI for Funkichain (EVM) only and will be expanding to other chains in the future  ","version":"Next","tagName":"h3"},{"title":"FUNKI DEX can save swappers money in the following ways:​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#funki-dex-can-save-swappers-money-in-the-following-ways","content":" Better prices by aggregating liquidity sourcesSwapping without network costsProtection against MEV attacks (front-running)No network costs for failed transactions  ","version":"Next","tagName":"h3"},{"title":"2. Connected Wallets on Funki Swap - Security Measures​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#2-connected-wallets-on-funki-swap---security-measures","content":" The Wallets connected on FUNKI Swap are self-custody wallets. They gives you full control over your digital assets, but also means you're responsible for safeguarding your recovery phrase, verifying transactions, and protecting yourself from scams. FUNKI cannot reverse transactions or recover funds on your behalf.  We are supporting some wallets: Metamask, Wallet Connect, …  ","version":"Next","tagName":"h3"},{"title":"Best Practices for Staying Safe​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#best-practices-for-staying-safe","content":" Never share your private keys or recovery phrase with anyone.Double-check all transaction details before signing.Be wary of unsolicited offers or requests involving your crypto.  ","version":"Next","tagName":"h3"},{"title":"3. Who uses the FUNKI protocol?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#3-who-uses-the-funki-protocol","content":" The FUNKI ecosystem includes three types of users: Liquidity Providers, Traders, and Developers.  Liquidity Providers (LPs): People who provide their crypto assets to help with trading.Traders: People who swap one token for another.Developers: People who work with FUNKI smart contracts to power new and exciting experiences.  In total, interactions between these classes create a positive feedback loop. They are the fuel that our digital economies need to define a common language. This common language allows users to pool and trade tokens.  ","version":"Next","tagName":"h3"},{"title":"a. Liquidity Providers:​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#a-liquidity-providers","content":" Liquidity providers, or LPs, provide ERC-20 tokens to FUNKI liquidity pools. Large pools generate higher-volume trades with better pricing than smaller pools.  Hence LPs play the very important role of providing liquidity for traders. In return, LPs earn a fee on every trade in the pool, split pro rata across LPs of that pool.  ","version":"Next","tagName":"h3"},{"title":"","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq##","content":" ","version":"Next","tagName":"h3"},{"title":"Different types of LP:​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#different-types-of-lp","content":" Passive LPs: token holders who wish to invest their assets to accumulate trading fees. This can generate passive income.Professional LPs: focus on market making as their primary strategy. They develop tools and ways of tracking their liquidity positions across different projects.DeFi Pioneers: explore complex liquidity provision interactions. Examples include incentivized liquidity, liquidity as collateral, and other experimental strategies. The FUNKI protocol is perfect for projects to experiment with these kinds of ideas. Token Projects: sometimes choose to become LPs to create a liquid market for their token. This allows users a simple way to buy and sell tokens.  ","version":"Next","tagName":"h3"},{"title":"b. Traders​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#b-traders","content":" There are a several categories of traders in the protocol ecosystem:  Speculators: individuals who use various community tools and products to swap tokens.Arbitrage Bots: These are our profit seeking bots! They compare prices across different platforms to find any competitive advantage. These bots actually help keep prices fair and equal.dapp Users: Individuals who buy tokens from the FUNKI protocol. They later trade these tokens in other applications on the Ethereum network.Smart contracts: execute trades on the protocol by implementing swap functionality. These products include DEX aggregators to custom Solidity scripts.  In all cases, trades are subject to the same flat fee for trading on the protocol. Each is important for increasing the accuracy of prices and incentivizing liquidity.  ","version":"Next","tagName":"h3"},{"title":"c. Developers​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#c-developers","content":" Developers build apps and services on top of the FUNKI protocol. There are too many to count across the Ethereum ecosystem, but some examples include:  FUNKI is completely open-source. Countless developers have launched their own front-ends to interact with the FUNKI protocol. You can find FUNKI functions in most of the major DeFi dashboard projects. There are also many FUNKI protocol tools built by the community.Wallets can integrate swapping and liquidity functionality as a core offering.DEX aggregators) pull liquidity from several liquidity protocols. This allows them to offer traders the best available prices. The Uniswap protocol is the biggest single decentralized liquidity source for these projects.Smart contract developers can invent new tools and experiment with other various ideas. Examples include projects like Unisocks or Zora, but the possibilities are limitless!  Many members of the FUNKI ecosystem take part in more than one of these roles. You can be a Liquidity Provider, Trader, and a Developer all at the same time!  ","version":"Next","tagName":"h3"},{"title":"4. What are FUNKI Swap’s fees?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#4-what-are-funki-swaps-fees","content":" Liquidity Provider Fee (LP Fee) is set by Liquidity Providers. There are 3 tiers:0.05%0.3%1%Protocol Fee/ Platform Fee  At the moment there are no protocol fees. However, it is possible for a 0.05% fee to be turned on in the future.  ","version":"Next","tagName":"h3"},{"title":"5. Supported Token List​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#5-supported-token-list","content":" Currently, FUNKI Swap supports ETH, USDT, &amp; SIPHER token only.We will support more tokens in the near future  ","version":"Next","tagName":"h3"},{"title":"6. Unsupported Token and NFT Policy​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#6-unsupported-token-and-nft-policy","content":" ","version":"Next","tagName":"h3"},{"title":"a. Asset blocking policy​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#a-asset-blocking-policy","content":" The FUNKI Protocol is a self-executing, permissionless, decentralized series of smart contracts that cannot be changed by anyone.  FUNKI maintains one of many ways to interact with the Protocol, and as a company based in the United States is subject to certain laws and regulations.  As such, there may be certain circumstances under which Labs blocks access to certain products through our own interfaces.  ","version":"Next","tagName":"h3"},{"title":"b. Ways that Access can be Restricted on FUNKI Interfaces​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#b-ways-that-access-can-be-restricted-on-funki-interfaces","content":" Blocks may be applied in two ways:  We can block specific token contracts by adding them to the Unsupported Tokens List. If a token contract is blocked: Any user viewing the corresponding token info page should see a message that the token is not supported; andInteractions (including both direct user actions and routing) with any liquidity pool including the blocked token should be disabled.Wallet users may still send and receive unsupported tokens. We can also block individual addresses. If a user attempts to connect or use a blocked address, all actions that would modify chain state are disabled. This type of block will generally be applied on the basis of sanctions lists or other third-party screening.  Blocking criteria will be identical across all our products (e.g., web, wallet).  ","version":"Next","tagName":"h3"},{"title":"c. Criteria for Restricting Access on FUNKI Interfaces​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#c-criteria-for-restricting-access-on-funki-interfaces","content":" We will block token contracts for four main reasons: Legal and regulatory requirements. An U.S. agency settlement or court judgment against the token’s issuer finds that the tokens/NFTs are regulated financial instruments (e.g., securities or derivatives) when traded in secondary transactions; or otherwise, upon internal legal review, and consultation with counsel; Fraud allegations. A major financial or criminal regulator files fraud allegations against the issuer; Intellectual property claims. A holder of intellectual property serves us with notice of plausible infringement of (i) a copyright (subject to notice and takedown provisions of the DMCA), or (ii) a trademark (not subject to the DMCA and its established counter-notice procedures), or (iii) the publicity rights of a third party (beyond the mere usage of a common name, and again not subject to the DMCA); or Risks to users. We believe there are technical, fraud, or other risks that could significantly affect user safety. We will block individual or smart contract addresses that are subject to U.S. government sanctions or associated with certain types of illegal activity. We may block individual or smart contract addresses for any other reason at our discretion. For example, we might have reason to believe that an address is associated with fraud, theft, or market manipulation, or that a smart contract has unacceptable security vulnerabilities.  ","version":"Next","tagName":"h3"},{"title":"7. How to initiate an appeal request​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#7-how-to-initiate-an-appeal-request","content":" To initiate an appeal for an unsupported asset on FUNKI interface, please follow these steps:  Email to hello@funkichain.com with “Appeal request” in the subject line.Include the name of the asset, contract address, and reason you’re appealing.FUNKI compliance team will acknowledge receipt of the request within xx business day.FUNKI will internally review appeal requests on a case-by-case basis.  ","version":"Next","tagName":"h3"},{"title":"8. Can I change slippage when using FUNKI Swap?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#8-can-i-change-slippage-when-using-funki-swap","content":"   Slippage can be adjusted for swaps using FUNKI Swap  ","version":"Next","tagName":"h3"},{"title":"9. How to swap on FUNKI Swap​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#9-how-to-swap-on-funki-swap","content":" Step 1 — Connect your wallet  Be sure your wallet supports all Chains &amp; Funki Chain mainnet you will be bridging onto.    Add Funki Chain Mainnet to your Wallet  Network name: Funki MainnetNetwork RPC URL:  https://rpc-mainnet.funkichain.com  Chain ID: 33979Currency symbol: ETHBlock explorer URL:  https://funkiscan.io/  Step 2: Select tokens &amp; specify the amount to be swapped  This is the on-chain swap. Currently, we just support users to swap SIPHER, ETH, USDT, USDC on Funki Swap    And then specify the amount you would like to swap. An estimate of the amount returned should appear in the quote field.  Step 3 - Review the swap details, and then select “Confirm Swap”.  Step 4 - Approve Spending  In your wallet, approve spending for the token you are swapping.  This will require a network cost. If this is your first time swapping the token with the Uniswap protocol, then you’ll need to approve the token in order to trade it.  Step 5 - In your wallet, sign the message. This transaction will not require a network cost.  Step 6 - In your wallet, confirm the swap.  This transaction requires network costs.  Once confirmed, your swap is submitted to the blockchain and is pending.    You will see “Swap success” and a green checkmark on screen when the transaction is successfully completed.    ","version":"Next","tagName":"h3"},{"title":"10. Is there a swap minimum for a FUNKI DEX transaction?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#10-is-there-a-swap-minimum-for-a-funki-dex-transaction","content":" No minimum has been set yet.  ","version":"Next","tagName":"h3"},{"title":"11. Why can my swap not be filled?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#11-why-can-my-swap-not-be-filled","content":" A swap might not be filled for the following reasons:  An error occurred while submitting the swapAn error occurred while signing the submissionA token approval may need to be revoked and approved again  There are no network costs charged when an unfilled or failed swap, so the swap can be submitted again.  ","version":"Next","tagName":"h3"},{"title":"12. Why did my swap expire?​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#12-why-did-my-swap-expire","content":" Swaps expire when swap is not filled within the designated time frame.  The deadline for a FUNKI DEX swap to be filled is 1 minute. If no filler fills the swap by then the swap will expire.  There are no network costs charged when an unfilled or failed swap, so the swap can be submitted again.  ","version":"Next","tagName":"h3"},{"title":"13. How to add liquidity to FUNKI​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#13-how-to-add-liquidity-to-funki","content":" FUNKI allows you to concentrate your liquidity position within a custom price range.  You can create a pair and pool for these supported tokens: ETH, WETH, USDT, USDC, SIPHER  ","version":"Next","tagName":"h3"},{"title":"14. How to remove liquidity from FUNKI​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#14-how-to-remove-liquidity-from-funki","content":" When removing liquidity from FUNKI, you will remove your liquidity position and collect earned fees.  Or, you only collect liquidity provider fees earned, without removing liquidity.  ","version":"Next","tagName":"h3"},{"title":"15. How to collect fees from a liquidity pool on FUNKI​","type":1,"pageTitle":"Funki DEX-FAQ","url":"/docs/tools/dexs/funki-dex-faq#15-how-to-collect-fees-from-a-liquidity-pool-on-funki","content":" FUNKI allows fees earned to be collected from the liquidity pool without removing liquidity.     ","version":"Next","tagName":"h3"},{"title":"thirdweb SDK","type":0,"sectionRef":"#","url":"/docs/tools/clients/thirdweb-sdk","content":"","keywords":"thirdweb SDK thirdweb Funki Funki mainnet Funki testnet Funki network web3 applications smart contracts React TypeScript","version":"Next"},{"title":"Install​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#install","content":" To install the thirdweb SDK, run:  npm install @thirdweb-dev/sdk ethers@5     ","version":"Next","tagName":"h2"},{"title":"Initializing the SDK with Funki​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#initializing-the-sdk-with-funki","content":" To get started using the SDK, you must first initialize an instance of ThirdWebSDK, and connect to the Funki network by passing in the Funki chain.  To initialize the SDK with the Funki network and get a contract:  import { Funki } from '@thirdweb-dev/chains'; import { ThirdwebSDK } from '@thirdweb-dev/sdk/evm'; const sdk = new ThirdwebSDK(Funki); const contract = await sdk.getContract('0x0000000000000000000000000000000000000000');   info The code snippet above uses the React SDK. The thirdweb SDKs are also available in React Native, TypeScript, Python, Go, and Unity. If alternatively you'd like to initialize the SDK with Funki Sepolia (testnet), use the following code instead: import { FunkiSepoliaSandbox } from '@thirdweb-dev/chains'; import { ThirdwebSDK } from '@thirdweb-dev/sdk/evm'; const sdk = new ThirdwebSDK(FunkiSepoliaSandbox); const contract = await sdk.getContract('0x0000000000000000000000000000000000000000');     ","version":"Next","tagName":"h2"},{"title":"Interacting with smart contracts​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#interacting-with-smart-contracts","content":" Once you initialize the SDK and connect to a smart contract deployed to Funki, you can start calling functions on it using the SDK.  info Any interaction you make with a smart contract will be made from the connected wallet automatically.  ","version":"Next","tagName":"h2"},{"title":"Using contract extension functions​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#using-contract-extension-functions","content":" The thirdweb SDK provides convenience functions when your smart contract uses extensions. This is the easiest way to read data and write transactions with your smart contracts.  For example, if your contract implements the ERC721 extension, you can utilize all of the functions of the corresponding erc721 standard in the SDK.  As an example, below is a code snippet that uses useOwnedNFTs hook to get a list of NFTs owned by a single wallet address:  import { useOwnedNFTs } from '@thirdweb-dev/react'; const { data, isLoading, error } = useOwnedNFTs(contract, '{{wallet_address}}');   Usage​  import { useOwnedNFTs, useContract, useAddress } from '@thirdweb-dev/react'; // Your smart contract address const contractAddress = '{{contract_address}}'; function App() { const address = useAddress(); const { contract } = useContract(contractAddress); const { data, isLoading, error } = useOwnedNFTs(contract, address); }   For more examples on using contract extension functions, visit the thirdweb developer documentation.  ","version":"Next","tagName":"h3"},{"title":"Reading contract data​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#reading-contract-data","content":" If your contract doesn’t use any extensions, or you want to directly call functions on your smart contract to read data, you can use the useContractRead hook.  Read data on your contract from a connected wallet:  const { contract } = useContract('{{contract_address}}'); const { data: myData, isLoading } = useContractRead(contract, 'myFunction');   ","version":"Next","tagName":"h3"},{"title":"Writing transactions​","type":1,"pageTitle":"thirdweb SDK","url":"/docs/tools/clients/thirdweb-sdk#writing-transactions","content":" If your contract doesn’t use any extensions, or you want to directly call functions on your smart contract to write data, you can use the useContractWrite hook.  Make transactions on your contract from a connected wallet:  const { contract } = useContract('{{contract_address}}'); const { mutateAsync: myFunctionAsync } = useContractWrite(contract, 'myFunction'); const tx = await myFunctionAsync(['argument1', 'argument2']); // Call the function  ","version":"Next","tagName":"h3"},{"title":"ethers.js","type":0,"sectionRef":"#","url":"/docs/tools/clients/ethers","content":"","keywords":"ethers.js JavaScript library Funki network Funki mainnet Funki testnet smart contracts EVM-compatible blockchain JsonRpcProvider Signer ABI interacting with smart contract","version":"Next"},{"title":"Install​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#install","content":" To install ethers.js run the following command:  npm install --save ethers   ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#setup","content":" Before you can start using ethers.js, you need to import it into your project.  Add the following line of code to the top of your file to import ethers.js:  const ethers = require('ethers');   ","version":"Next","tagName":"h2"},{"title":"Connecting to Funki​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#connecting-to-funki","content":" You can connect to Funki by instantiating a new ethers.js JsonRpcProvider object with a RPC URL of the Funki network:  const ethers = require('ethers'); const url = 'https://rpc-mainnet.funkichain.com'; const provider = new ethers.providers.JsonRpcProvider(url);   info To alternatively connect to Funki Sepolia (testnet), change the above URL from https://rpc-mainnet.funkichain.com to https://funki-testnet.alt.technology.  ","version":"Next","tagName":"h2"},{"title":"Reading data from the blockchain​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#reading-data-from-the-blockchain","content":" Once you have created a provider, you can use it to read data from the Funki network.  For example, you can use the getBlockNumber method to get the latest block:  async function getLatestBlock() { const latestBlock = await provider.getBlockNumber(); console.log(latestBlock); }   ","version":"Next","tagName":"h2"},{"title":"Writing data to the blockchain​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#writing-data-to-the-blockchain","content":" In order to write data to the Funki network, you need to create a Signer.  You can create a Signer by instantiating a new ethers.js Wallet object, providing it with a private key and Provider.  const privateKey = 'PRIVATE_KEY'; const signer = new ethers.Wallet(privateKey, provider);   info PRIVATE_KEY is the private key of the wallet to use when creating the signer.  ","version":"Next","tagName":"h2"},{"title":"Interacting with smart contracts​","type":1,"pageTitle":"ethers.js","url":"/docs/tools/clients/ethers#interacting-with-smart-contracts","content":" You can use ethers.js to interact with a smart contract on Funki by instantiating a Contract object using the ABI and address of a deployed contract:  const abi = [ … // ABI of deployed contract ]; const contractAddress = &quot;CONTRACT_ADDRESS&quot; // read only const contract = new ethers.Contract(contractAddress, abi, provider);   For write-only contracts, provide a Signer object instead of a Provider object:  // write only const contract = new ethers.Contract(contractAddress, abi, signer);   info CONTRACT_ADDRESS is the address of the deployed contract.  Once you have created a Contract object, you can use it to call desired methods on the smart contract:  async function setValue(value) { const tx = await contract.set(value); console.log(tx.hash); } async function getValue() { const value = await contract.get(); console.log(value.toString()); }  ","version":"Next","tagName":"h2"},{"title":"thirdweb CLI","type":0,"sectionRef":"#","url":"/docs/tools/toolchains/thirdweb-cli","content":"","keywords":"thirdweb CLI thirdweb CLI Funki Funki mainnet Funki testnet Funki network smart contracts deploy smart contract test smart contract debug smart contract web3 applications","version":"Next"},{"title":"Creating a project​","type":1,"pageTitle":"thirdweb CLI","url":"/docs/tools/toolchains/thirdweb-cli#creating-a-project","content":" Create a new project with thirdweb installed and configured:  npx thirdweb create   info When you create a project for smart contracts or web3 apps there are various configurable options. For contracts, some options are: Create a new contract project using Hardhat or ForgeAdd a new contract to an existing projectStart from an audited contract base, and add optional extensions For contracts, some options are: Front end applications using Next, CRA or ViteBackend applications using Node.js or Express.jsChoice of TypeScript or JavaScript variants    ","version":"Next","tagName":"h2"},{"title":"Deploying a smart contract​","type":1,"pageTitle":"thirdweb CLI","url":"/docs/tools/toolchains/thirdweb-cli#deploying-a-smart-contract","content":" Deploy your smart contracts to the Funki network:  npx thirdweb deploy   info To deploy to the Funki network, after running npx thirdweb deploy, visit the provided dashboard URL and select Funki from the Network dropdown.    ","version":"Next","tagName":"h2"},{"title":"Publishing a smart contract​","type":1,"pageTitle":"thirdweb CLI","url":"/docs/tools/toolchains/thirdweb-cli#publishing-a-smart-contract","content":" Publish and share a versioned release of your contract onto thirdweb’s registry:  npx thirdweb publish    ","version":"Next","tagName":"h2"},{"title":"web3.js","type":0,"sectionRef":"#","url":"/docs/tools/clients/web3","content":"","keywords":"web3.js Funki Funki mainnet Funki testnet Funki network JavaScript EVM client library blockchain smart contracts Ethereum RPC URL","version":"Next"},{"title":"Install​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#install","content":" To install web3.js run the following command:  npm install web3   ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#setup","content":" Before you can start using web3.js, you need to import it into your project.  Add the following line of code to the top of your file to import web3.js:  //web3.js v1 const Web3 = require('web3'); //web3.js v4 const { Web3 } = require('web3');   ","version":"Next","tagName":"h2"},{"title":"Connecting to Funki​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#connecting-to-funki","content":" You can connect to Funki by instantiating a new web3.js Web3 object with a RPC URL of the Funki network:  const { Web3 } = require('web3'); const web3 = new Web3('https://rpc-mainnet.funkichain.com');   info To alternatively connect to Funki Sepolia (testnet), change the above URL from https://rpc-mainnet.funkichain.com to https://funki-testnet.alt.technology.  ","version":"Next","tagName":"h2"},{"title":"Accessing data​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#accessing-data","content":" Once you have created a provider, you can use it to read data from the Funki network.  For example, you can use the getBlockNumber method to get the latest block:  async function getLatestBlock(address) { const latestBlock = await web3.eth.getBlockNumber(); console.log(latestBlock.toString()); }   ","version":"Next","tagName":"h2"},{"title":"Deploying contracts​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#deploying-contracts","content":" Before you can deploy a contract to the Funki network using web3.js, you must first create an account.  You can create an account by using web3.eth.accounts:  const privateKey = “PRIVATE_KEY”; const account = web3.eth.accounts.privateKeyToAccount(privateKey);   info PRIVATE_KEY is the private key of the wallet to use when creating the account.  ","version":"Next","tagName":"h2"},{"title":"Interacting with smart contracts​","type":1,"pageTitle":"web3.js","url":"/docs/tools/clients/web3#interacting-with-smart-contracts","content":" You can use web3.js to interact with a smart contract on Funki by instantiating a Contract object using the ABI and address of a deployed contract:  const abi = [ … // ABI of deployed contract ]; const contractAddress = &quot;CONTRACT_ADDRESS&quot; const contract = new web3.eth.Contract(abi, contractAddress);   Once you have created a Contract object, you can use it to call desired methods on the smart contract:  async function setValue(value) { // write query const tx = await contract.methods.set(value).send(); console.log(tx.transactionHash); } async function getValue() { // read query const value = await contract.methods.get().call(); console.log(value.toString()); }   info ","version":"Next","tagName":"h2"},{"title":"Deploying a smart contract using Remix","type":0,"sectionRef":"#","url":"/docs/tutorials/deploy-sm-using-remix","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#objectives","content":" By the end of this tutorial, you'll be able to:  Understand Remix's features, advantages, and limitations as an IDEDeploy and test the Storage.sol demo contract using RemixDeploy a contract to the FunkiSepolia using Remix and interact with it    ","version":"Next","tagName":"h2"},{"title":"Remix Window Overview​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#remix-window-overview","content":" To begin, open a browser window and navigate to https://remix.ethereum.org. After navigating through the introductory tips, you'll encounter the editor, which is neatly divided into three familiar sections.  ","version":"Next","tagName":"h2"},{"title":"Editor Pane​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#editor-pane","content":" The editor pane initially showcases the Remix home screen, complete with news, useful links, and cautionary notes about prevalent scams. Feel free to dismiss the home tab and open 1_Storage.sol, which resides in the contracts folder within the default_workspace.  // SPDX-License-Identifier: GPL-3.0 pragma solidity &gt;=0.7.0 &lt;0.9.0; /** * @title Storage * @dev Store &amp; retrieve value in a variable * @custom:dev-run-script ./scripts/deploy_with_ethers.ts */ contract Storage { uint256 number; /** * @dev Store value in variable * @param num value to store */ function store(uint256 num) public { number = num; } /** * @dev Return value * @return value of 'number' */ function retrieve() public view returns (uint256){ return number; } }   You'll edit your code in the editor pane. It offers most of the features you'd expect, including syntax highlighting and error detection. However, in Remix, errors aren't underlined. Instead, you'll see an ❗ icon to the left of the line number where an error occurs.  At the top, you'll notice a large green arrow, similar to the Run button in other editors. In Solidity, this button compiles your code but doesn't run it. That's because you must first deploy your code to the simulated blockchain before execution.  ","version":"Next","tagName":"h3"},{"title":"Terminal/Output​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#terminaloutput","content":" Below the editor pane, you'll find the terminal.    This panel primarily displays transaction logs from your smart contracts and provides access to Remix's powerful debugging tools.  ","version":"Next","tagName":"h3"},{"title":"Left Panel​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#left-panel","content":" Similar to many other editors, Remix's left panel contains several vertical tabs for navigating between tools and functions. This panel allows you to browse files in your current workspace, manage workspaces, search your code, and access a variety of plugins.    ","version":"Next","tagName":"h3"},{"title":"Plugins​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#plugins","content":" Remix's functionality relies heavily on plugins, with the most common ones activated by default. To manage plugins, click the plug icon in the lower-left corner, just above the settings gear. You can easily toggle plugins on or off by clicking &quot;activate&quot; or &quot;deactivate.&quot; Some plugins, such as the Debug tool, automatically activate when needed through other parts of the editor.  ","version":"Next","tagName":"h2"},{"title":"Solidity Compiler​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#solidity-compiler","content":" The first default plugin (after the search function) is the Solidity Compiler. Be sure to enable the Auto compile option. Smart contracts are typically very small files, so this shouldn't cause any performance issues while editing code.  The Compile and Run script button in this plugin can be misleading. It's important to note that this is not the usual method for testing your contract. For more information on this feature, click the I button.  If your contracts contain errors, you'll find the complete error messages at the bottom of the page. To see this in action, try introducing some typos into 1_Storage.sol.  ","version":"Next","tagName":"h3"},{"title":"Deploy & Run Transactions​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#deploy--run-transactions","content":" The &quot;Deploy &amp; Run Transactions&quot; plugin is your primary tool for deploying and interacting with contracts. At the top, you'll see options to select your virtual machine, create mock user wallets with test Ether, and a dropdown menu for choosing the contract you want to deploy and test.  After fixing any errors in 1_Storage.sol, click the orange Deploy button. Your contract will appear below as STORAGE AT &lt;address&gt;  caution Deploying contracts in Remix can be tricky due to two potential pitfalls: Each time you click the Deploy button, Remix creates a new instance of your contract while retaining previous deployments. Unless you're comparing versions or deploying multiple contracts, it's best to click the Trash button to remove old deployments before deploying again.If your code fails to compile, clicking Deploy won't trigger an error message! Instead, Remix will deploy the last successfully compiled version. Always check for errors—indicated by a red circle with a number on the Compiler plugin—before deploying.    ","version":"Next","tagName":"h3"},{"title":"Prepare for Deployment​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#prepare-for-deployment","content":" Testnets closely mirror their corresponding main networks, but with a few key distinctions. To interact with a testnet—whether you're deploying a new contract or calling functions in an existing one—you'll need a wallet loaded with the appropriate testnet tokens.  ","version":"Next","tagName":"h2"},{"title":"Set Up a Wallet​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#set-up-a-wallet","content":" If you've already set up a wallet exclusively for development, feel free to skip ahead. If not, now's the perfect time to take the plunge!  danger Using a wallet with valuable assets for development is extremely risky. You might inadvertently write code with a bug that transfers incorrect amounts or tokens to the wrong addresses. Remember, blockchain transactions are irreversible once sent! Stay safe by using separate wallets for different purposes.  First, add the Coinbase or MetaMask wallet to your browser and set up a new wallet. As a developer, you must be extra vigilant about your wallet's security! Many apps grant special privileges to the contract owner's wallet address—allowing the withdrawal of all Ether paid by customers or altering crucial settings.  After setting up your wallet, enable developer settings and activate testnets (Coinbase Settings, MetaMask Settings).  ","version":"Next","tagName":"h3"},{"title":"Add the FunkiSepolia to your Wallet​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#add-the-funkisepolia-to-your-wallet","content":" Most wallets include the FunkiSepolia as one of the default testnet networks. You may need to enable developer mode to view them.  For this tutorial, you'll deploy a contract to the FunkiSepolia. To fund your wallet with Funki Sepolia ETH, use one of the faucets listed on the Funki Network Faucets page.  ","version":"Next","tagName":"h3"},{"title":"Get Testnet Ether​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#get-testnet-ether","content":" Testnet tokens have no real monetary value, but their supply is limited. Use a faucet to obtain a small amount of Sepolia Ether for paying gas fees during testing. Most faucets allow you to request a modest sum daily, and some will refuse to send more if your balance is already high.  It's wise to bookmark multiple faucets, which you can easily find through a simple search. This precaution helps because faucets occasionally go offline. Faucet providers often battle against malicious actors and may need to temporarily disable their services.  You can access the FunkiSepolia faucet for some test tokens.  After obtaining testnet Funki Sepolia Ether, you can view your balance under the Testnets tab in the Coinbase wallet, or by selecting the testnet from the network dropdown in MetaMask. Don't get too excited, though—despite the impressive numbers you might see, it's not actually worth real money!    ","version":"Next","tagName":"h3"},{"title":"Deploying to Testnet​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#deploying-to-testnet","content":" With testnet Ether in hand, you're ready to deploy the Storage contract!  ","version":"Next","tagName":"h2"},{"title":"Selecting the Environment​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#selecting-the-environment","content":" Navigate to the Deploy &amp; Run Transactions tab. In the Environment dropdown, choose Injected Provider. This will display Coinbase, MetaMask, or any other wallet you've activated.    Can't find the option? No worries—just select Customize this list... to add it.    Your first connection will trigger a wallet prompt, asking you to confirm linking Remix to your wallet.  Once connected, you'll spot the network name right below the Environment dropdown.  For the FunkiSepolia, look for Custom (3397901) network. (Note: Deploying to mainnet? You'll see Custom (33979) network instead.)  If the network doesn't match, simply switch to the correct one in your wallet.  ","version":"Next","tagName":"h3"},{"title":"Deploy the Contract​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#deploy-the-contract","content":" Click the orange Deploy button. Because it costs gas to deploy a contract, you'll be asked to review and confirm a transaction.  danger Always carefully review all transactions, confirming the transaction cost, assets transferred, and network. As a developer, you'll become accustomed to approving transactions frequently. Make a conscious effort to avoid falling into the habit of clicking Confirm without thoroughly examining the transaction details. If you feel rushed to Confirm before time runs out, it's likely a scam. After clicking the Confirm button, return to Remix and wait for the transaction to deploy. Copy its address and navigate to https://funkiscan.io/. Note: If you deployed to mainnet, you'll navigate to https://funkiscan.io/ instead.  ","version":"Next","tagName":"h3"},{"title":"Verify the Contract​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#verify-the-contract","content":" info Verifying the contract is unnecessary if you've deployed one that's identical to a previously verified contract.  You can interact with your deployed contract using Remix as before, but it's also possible to interact through FunkiScan. Simply paste your contract's address in the search field to locate it.  To verify your contract, use the FunkiScan verification tool. Follow these steps:  Enter your deployed contract's address.Select your programming language.Provide the compiler information and upload your file(s). Ensure this information matches exactly what you used when compiling your contract for deployment. You can upload multiple files or a single flattened file.Click &quot;Verify Contract&quot; and await the result.    After successfully verify, you will be able to see your contract’s source code on FunkiScan just like this.    ","version":"Next","tagName":"h3"},{"title":"Interact with the Contract on FunkiScan​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#interact-with-the-contract-on-funkiscan","content":" You can now interact with your contract using FunkiChain. Click the Contract tab. If your contract is verified, you'll see the contract's source code and all its functions under the Read Contract and Write Contract buttons. Note that only write functions require an on-chain transaction.  To interact with write functions, you need to sign in to FunkiChain with your wallet. Currently, you can choose from any of the supported wallet providers that appear.    Once connected, you're all set to interact with any write function of the contract. Make sure your input is correct and double-check the transaction details before confirming any transaction.    ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a smart contract using Remix","url":"/docs/tutorials/deploy-sm-using-remix#conclusion","content":" Congratulations! You've now acquired the ability to deploy smart contracts on the blockchain. While you've only deployed to a test network so far, the process for real networks is identical—just with higher costs! ","version":"Next","tagName":"h2"},{"title":"Simple Fungible Tokens","type":0,"sectionRef":"#","url":"/docs/tutorials/simple-fungible-tokens","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#objectives","content":" By the end of this tutorial, you'll learn how to:  Understand the fundamental concepts of ERC-20 tokensCreate your own ERC-20 tokens using code    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#prerequisites","content":" ","version":"Next","tagName":"h2"},{"title":"ERC-20 Tokens​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#erc-20-tokens","content":" This tutorial assumes you can write, test, and deploy ERC-20 tokens using Solidity. If you need to refresh these skills, explore some introductory resources first.  ","version":"Next","tagName":"h3"},{"title":"What is the ERC-20 token standard?​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#what-is-the-erc-20-token-standard","content":" The ERC-20 token standard ensures all tokens have identical properties. It guarantees that tokens are fungible (each token is exactly equal to any other) and that no tokens possess special properties or rights.  For a token to adhere to the ERC-20 standard, it must implement these API methods and events:  totalSupply: Defines the total token supply and halts new token creation when the limit is reached.balanceOf: Returns the number of tokens in a given wallet address.transfer: Moves a specified amount of tokens from the total supply to a user.transferFrom: Transfers ERC-20 tokens between users.approve: Verifies if a smart contract can allocate a certain amount of tokens to a user, considering the total supply.allowance: Checks if a user has sufficient balance to send tokens to another user.  ERC-20 tokens are fungible (interchangeable) due to their identical value and properties. Other token standards include non-fungible and semi-fungible types, such as ERC-721 and ERC-1155 tokens.  ","version":"Next","tagName":"h2"},{"title":"Write ERC-20 Token Smart Contract​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#write-erc-20-token-smart-contract","content":" Here’s how to write the token contract for your ERC-20 token using Solidity  //SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;; // OpenZeppelin package contains implementation of the ERC 20 standard, which our NFT smart contract will inherit contract FunkiToken is ERC20 { uint constant _initial_supply = 100 * (10**18); // setting variable for how many of your own tokens are initially put into your wallet, feel free to edit the first number but make sure to leave the second number because we want to make sure our supply has 18 decimals /* ERC 20 constructor takes in 2 strings, feel free to change the first string to the name of your token name, and the second string to the corresponding symbol for your custom token name */ constructor() ERC20(&quot;FunkiToken&quot;, &quot;FUN&quot;) public { _mint(msg.sender, _initial_supply); } }   The token symbol you choose (in our case &quot;FUN&quot;) can be any length. However, be aware that some user interfaces may display longer symbols differently.  You can adjust the initial supply by changing the value 100 to your desired number of tokens. We chose 100 because FunkiTokens are rare! Feel free to use any number you prefer—just ensure you keep the (10**18) part, as it maintains 18 decimal places for your token supply.  For demonstration purposes, this token will be minted entirely and given to the deployer. In practice, you can separate the token minting function and add conditions based on your project's specific requirements.  For example, here's a mint function restricted to users with the MINTER_ROLE, where the recipient can't be the contract itself:  function mint(address _to, uint256 _amount) onlyHasRole(MINTER_ROLE) override external { require(_to != address(this), &quot;unable to mint tokens to itself&quot;); _mint(_to, _amount); }   To implement access control modifiers like in this example, you can refer to OpenZeppelin's AccessControl contract implementation.  ","version":"Next","tagName":"h2"},{"title":"Deploy Contract​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#deploy-contract","content":" To deploy the contract, you can refer to our tutorials that suit your preferred tech stack:  Deploying a smart contract using FoundryDeploying a smart contract using HardhatDeploying a smart contract using Remix  ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Simple Fungible Tokens","url":"/docs/tutorials/simple-fungible-tokens#conclusion","content":" Thanks to robust libraries like OpenZeppelin, creating and launching fungible ERC-20 tokens has become remarkably simple. These tools streamline complex token functionalities, freeing developers to focus on their projects' unique aspects. Even those with limited blockchain experience can now efficiently create secure, compliant ERC-20 tokens. This accessibility opens up a world of possibilities for digital asset creation and management. ","version":"Next","tagName":"h2"},{"title":"Verify a Smart Contract on FunkiScan","type":0,"sectionRef":"#","url":"/docs/tutorials/verify-sm-on-funkichain","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#objectives","content":" By the end of this tutorial, you should be able to:  Verify your deployed contract with popular Frameworks and toolkits.Verify contract directly on FunkiScan.    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#prerequisites","content":" Familiarity with smart contract development and the Solidity programming languageSolidity is the primary language for writing smart contracts on Ethereum and Ethereum-compatible blockchains like Funki. You should be comfortable writing, compiling, and deploying basic smart contracts using Solidity.Basic understanding of popular frameworks and toolkits for Ethereum developmentFrameworks and toolkits streamline the process of deploying, testing, and interacting with smart contracts. You should be familiar with popular smart contract development tools like Hardhat, Foundry    ","version":"Next","tagName":"h2"},{"title":"Hardhat verification​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#hardhat-verification","content":" hardhat-verify is a Hardhat plugin that simplifies the smart contract verification process on Etherscan. Thanks to the Etherscan Compatible Verify Contract API, you can also use this tool to verify your smart contract on FunkiScan.  Here's an example of a hardhat.config.ts file:  import { HardhatUserConfig } from &quot;hardhat/config&quot;; import &quot;@nomicfoundation/hardhat-toolbox&quot;; import &quot;@nomiclabs/hardhat-verify&quot;; const config: HardhatUserConfig = { etherscan: { apiKey: { funkiscan: &quot;funkiscan&quot;, // apiKey is not required, just set a placeholder }, customChains: [ { network: &quot;funki&quot;, chainId: 33979, urls: { apiURL: &quot;https://api.routescan.io/v2/network/mainnet/evm/33979_2/etherscan/api&quot;, browserURL: &quot;https://funkiscan.io&quot; } } ] }, networks: { funki: { url: 'https://rpc-mainnet.funkichain.com', accounts: [process.env.PRIVATE_KEY] }, }, }; export default config;   Deploy  npx hardhat run scripts/deploy.ts --network funki   Verify  export PRIVATE_KEY=... npx hardhat verify --network funki 0x...     ","version":"Next","tagName":"h2"},{"title":"Foundry verification​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#foundry-verification","content":" Foundry allows you to verify contracts either during deployment or as a separate step. Be sure to include the --verifier-url option in your deploy or verify script.  To verify at deployment time:  forge script scripts/Deploy.s.sol --broadcast --rpc-url [NETWORK_RPC_URL] --verifier-url 'https://api.routescan.io/v2/network/mainnet/evm/33979_2/etherscan/api' --etherscan-api-key &quot;verifyContract&quot;   To verify a contract that has already been deployed:  forge verify-contract [contract-address] [src/path/ContractPath.sol:ContractName] --verifier-url 'https://api.routescan.io/v2/network/mainnet/evm/33979_2/etherscan/api' --etherscan-api-key &quot;verifyContract&quot; --num-of-optimizations 200 --compiler-version [solc compiler version] --constructor-args $(cast abi-encode &quot;constructor(address param1, uint256 param2,...)&quot; param1 param2 ...)     ","version":"Next","tagName":"h2"},{"title":"FunkiScan verify contract with files​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#funkiscan-verify-contract-with-files","content":" You can verify contracts using the FunkiScan verification tool. This method is particularly useful if you've deployed your contract with Remix IDE and need to verify it.  Step 1: Enter your deployed contract's address.Step 2: Choose your programming language.Step 3: Provide the compiler information and upload your file(s). Make sure this information exactly matches what you used when compiling your contract for deployment. You can upload either multiple files or a single flattened file.Step 4: Click &quot;Verify Contract&quot; and wait for the result.      ","version":"Next","tagName":"h2"},{"title":"Interact with the Contract on FunkiScan​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#interact-with-the-contract-on-funkiscan","content":" You can now interact with your contract using FunkiChain. Click the Contract tab. If your contract is verified, you'll see the contract's source code and all its functions under the Read Contract and Write Contract buttons. Note that only write functions require an on-chain transaction.  To interact with write functions, you need to sign in to FunkiChain with your wallet. Currently, you can choose from any of the supported wallet providers that appear.    Once connected, you're all set to interact with any write function of the contract. Make sure your input is correct and double-check the transaction details before confirming any transaction.    ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Verify a Smart Contract on FunkiScan","url":"/docs/tutorials/verify-sm-on-funkichain#conclusion","content":" Congratulations! You've now mastered the art of deploying smart contracts to the blockchain. While you've only deployed to a test network so far, the process for real networks is identical—just remember, it comes with a heftier price tag! ","version":"Next","tagName":"h2"},{"title":"Using Funki with your wallet","type":0,"sectionRef":"#","url":"/docs/using-funki","content":"","keywords":"Funki MetaMask EVM-compatible wallets network configuration Funki mainnet Funki testnet Sepolia cryptocurrency wallet setup Funki wallet setup add Funki network","version":"Next"},{"title":"MetaMask​","type":1,"pageTitle":"Using Funki with your wallet","url":"/docs/using-funki#metamask","content":" Funki can be added as a custom network to any EVM-compatible wallet (i.e. MetaMask).  ","version":"Next","tagName":"h2"},{"title":"Mainnet​","type":1,"pageTitle":"Using Funki with your wallet","url":"/docs/using-funki#mainnet","content":" To add Funki as a custom network to MetaMask:  Open the MetaMask browser extension. Open the network selection dropdown menu by clicking the dropdown button at the top of the extension. Click the Add network button. Click Add a network manually. In the Add a network manually dialog that appears, enter the following information for Funki mainnet: Name\tValueNetwork Name\tFunki Mainnet Description\tThe public mainnet for Funki. RPC Endpoint\thttps://rpc-mainnet.funkichain.com Chain ID\t33979 Currency Symbol\tETH Block Explorer\thttps://funkiscan.io/ Tap the Save button to save Funki as a network.  You should now be able to connect to the Funki by selecting it from the network selection dropdown menu.    ","version":"Next","tagName":"h3"},{"title":"Testnet​","type":1,"pageTitle":"Using Funki with your wallet","url":"/docs/using-funki#testnet","content":" To add Funki Testnet as a custom network to MetaMask:  Open the MetaMask browser extension. Open the network selection dropdown menu by clicking the dropdown button at the top of the extension. Click the Add network button. Click Add a network manually. In the Add a network manually dialog that appears, enter the following information for the Funki testnet: Name\tValueNetwork Name\tFunki Testnet RPC Endpoint\thttps://funki-testnet.alt.technology Chain ID\t3397901 Currency Symbol\tETH Block Explorer\thttps://testnet.funkiscan.io/ Tap the Save button to save Funki Testnet as a network.  You should now be able to connect to the Funki testnet by selecting it from the network selection dropdown menu.   ","version":"Next","tagName":"h3"},{"title":"Deploying a smart contract using thirdweb","type":0,"sectionRef":"#","url":"/docs/tutorials/deploy-sm-using-thirdweb","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#objectives","content":" By the end of this lesson, you'll be able to:  Create a project with a smart contract using thirdwebDeploy smart contracts using thirdwebInteract with deployed smart contracts using thirdweb    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#prerequisites","content":" The interactive thirdweb command line interface (CLI) provides all the tools necessary to create, build, and deploy smart contracts and apps to Funki.  For the most up-to-date version, we recommend using npx. However, you can also install the CLI globally on your machine:  npm i -g @thirdweb-dev/cli     ","version":"Next","tagName":"h2"},{"title":"Creating a project​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#creating-a-project","content":" The thirdweb CLI enables you to create a new project with a smart contract. You can also deploy pre-built contracts for NFTs, Tokens, or Marketplaces directly from the thirdweb Explore page.  To create a new project using the CLI, run this command:  npx thirdweb create contract   This will initiate an interactive series of prompts to guide you through the setup process:  Name your projectChoose Hardhat as the frameworkSelect ERC721 for the base contractOpt for &quot;None&quot; when asked about optional extensions  ","version":"Next","tagName":"h2"},{"title":"Exploring the project​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#exploring-the-project","content":" The create command generates a new directory with your project name. Open this directory in your text editor.  Inside the contracts folder, you'll find a Contract.sol file—this is your smart contract written in Solidity!  Examining the code, you'll see that our contract inherits the functionality of ERC721Base by:  Importing the contractInheriting the contract (declaring that our contract is ERC721Base)Implementing required methods, such as the constructor  // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import &quot;@thirdweb-dev/contracts/base/ERC721Base.sol&quot;; contract Contract is ERC721Base { constructor( string memory _name, string memory _symbol, address _royaltyRecipient, uint128 _royaltyBps ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {} }   This inheritance pattern lets us use functionality from other contracts inside of ours, modify it, and add custom logic.  For example, our contract currently implements all of the logic inside the ERC721Base.sol contract, which implements the ERC721A standard with several useful extensions.    ","version":"Next","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#deploying-the-contract","content":" You can use the thirdweb CLI to deploy a smart contract to Funki.  To deploy your smart contracts, from the root directory of your project, run:  npx thirdweb deploy   Running this command will:  Compile all contracts in the current directoryAllow you to select which contract(s) to deployUpload your contract's source code (ABI) to IPFSOpen the deployment flow in the dashboard  From the dashboard, you'll need to enter the values for your contract's constructor:  _name: Your contract's name_symbol: The &quot;ticker&quot; symbol for your contract's tokens_royaltyRecipient: The wallet address receiving royalties from secondary sales_royaltyBps: The basis points (bps) for royalties on each secondary sale (e.g., 500 = 5%)  Lastly, choose the FunkiSepolia as your deployment network, then click Deploy Now.  info For production / mainnet deployments select FunkiMainet as the network rather than FunkiSepolia.  Once your contract is deployed, you'll be redirected to a dashboard for managing your contract.    ","version":"Next","tagName":"h2"},{"title":"Interacting with your contract​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#interacting-with-your-contract","content":" Thirdweb provides SDKs for various programming languages, including React, React Native, TypeScript, Python, Go, and Unity.  To interact with your smart contract, you can use the thirdweb CLI to create a web application that is pre-configured with the thirdweb React SDK.  To create a web application preconfigured with the thirdweb SDK, run:  npx thirdweb create app --evm   This will kick off an interactive series of questions to help you get started:  Give your project a nameSelect Create React App as the frameworkSelect TypeScript as the language  ","version":"Next","tagName":"h2"},{"title":"Exploring the project​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#exploring-the-project-1","content":" The create command generates a new directory with your project name. Open this directory in your text editor.  In the index.tsx file, you'll find the ThirdwebProvider wrapping the entire application.  This wrapper enables the use of all React SDK hooks and UI Components throughout the application. It also allows you to configure an activeChain, which specifies the blockchain network for your smart contracts.  Since we deployed our smart contract to the Funki network, we'll set the activeChain to FunkiSepolia:  ... import { FunkiSepolia } from &quot;@thirdweb-dev/chains&quot;; import { ThirdwebProvider } from &quot;@thirdweb-dev/react&quot;; const container = document.getElementById(&quot;root&quot;); const root = createRoot(container!); root.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;ThirdwebProvider activeChain={FunkiSepolia}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/ThirdwebProvider&amp;gt; &amp;lt;/React.StrictMode&amp;gt; );   ","version":"Next","tagName":"h3"},{"title":"Interacting with the contract​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#interacting-with-the-contract","content":" To connect to your smart contract in the application, provide your smart contract address (which you can get from the dashboard) to the useContract hook like so:  import { useContract } from '@thirdweb-dev/react'; export default function Home() { const { contract } = useContract('&amp;lt;CONTRACT_ADDRESS&amp;gt;'); // Now you can use the contract in the rest of the component! }   You can now call any function on your smart contract with useContractRead and useContractWrite hooks.  For example, you can call useContractRead to get the name of the contract:  const { data, isLoading } = useContractRead(contract, 'name');   The thirdweb SDK offers hooks for various interfaces and extensions, simplifying data reading and writing. For instance, we can use ERC721 hooks to retrieve metadata for our NFT contract.  To learn more about interacting with smart contracts using the thirdweb SDK, check out the thirdweb developer documentation.  ","version":"Next","tagName":"h3"},{"title":"Deploying the project​","type":1,"pageTitle":"Deploying a smart contract using thirdweb","url":"/docs/tutorials/deploy-sm-using-thirdweb#deploying-the-project","content":" To host your application on IPFS, run the following command:  yarn deploy   This command uses Storage to:  Create a production build of your applicationUpload the build to IPFSGenerate a URL where your app is permanently hosted  That's it! You now have a web application that interacts with smart contracts deployed to Funki! ","version":"Next","tagName":"h3"},{"title":"Deploying a smart contract using Foundry","type":0,"sectionRef":"#","url":"/docs/tutorials/deploy-sm-using-foundry","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#objectives","content":" By the end of this tutorial, you'll be able to:  Set up Foundry for Funki developmentCreate an NFT smart contract compatible with FunkiCompile a smart contract for Funki using forgeDeploy a smart contract to Funki using forgeInteract with a deployed smart contract on Funki using cast    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#prerequisites","content":" ","version":"Next","tagName":"h2"},{"title":"Foundry​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#foundry","content":" This tutorial requires Foundry. To install it:  Run this command in your terminal: curl -L https://foundry.paradigm.xyz | bashThen run foundryup to install the latest (nightly) build of Foundry  For more details, consult the Foundry Book's installation guide.  ","version":"Next","tagName":"h3"},{"title":"Web3 Wallet​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#web3-wallet","content":" To deploy a smart contract, you'll need a web3 wallet. Create one by installing a wallet browser extension:  Install MetaMask WalletInstall Coinbase Wallet  ","version":"Next","tagName":"h3"},{"title":"Wallet Funds​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#wallet-funds","content":" Deploying contracts requires ETH for gas fees. For this tutorial, you'll deploy to the Funnki testnet. Fund your wallet with Funki Sepolia ETH using a faucet listed on the Funki Network Faucets page.    ","version":"Next","tagName":"h3"},{"title":"Creating a Project​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#creating-a-project","content":" Before deploying smart contracts to Funki, set up your development environment by creating a Foundry project.  To create a new Foundry project, first create a directory:  mkdir myproject   Then run:  cd myproject forge init   This creates a Foundry project with the following basic layout:  . ├── foundry.toml ├── script │ └── Counter.s.sol ├── src │ └── Counter.sol └── test └── Counter.t.sol     ","version":"Next","tagName":"h2"},{"title":"Compiling the Smart Contract​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#compiling-the-smart-contract","content":" Here's a simple NFT (non-fungible token) smart contract that conforms to the ERC-721 standard, written in Solidity:  // SPDX-License-Identifier: MIT pragma solidity ^0.8.23; import &quot;openzeppelin-contracts/contracts/token/ERC721/ERC721.sol&quot;; contract NFT is ERC721 { uint256 public currentTokenId; constructor() ERC721(&quot;NFT Name&quot;, &quot;NFT&quot;) {} function mint(address recipient) public payable returns (uint256) { uint256 newItemId = ++currentTokenId; _safeMint(recipient, newItemId); return newItemId; } }   This Solidity code defines an NFT smart contract using the ERC721 interface from the OpenZeppelin Contracts library. OpenZeppelin offers battle-tested smart contract implementations that comply with official ERC standards.  To incorporate the OpenZeppelin Contracts library into your project, execute:  forge install openzeppelin/openzeppelin-contracts   In your project, replace the generated src/Counter.sol contract with the above code in a new file called contracts/NFT.sol. (You can also remove test/Counter.t.sol and script/Counter.s.sol, but be sure to add your own tests soon!)  To compile our basic NFT contract using Foundry, run:  forge build     ","version":"Next","tagName":"h2"},{"title":"Configuring Foundry with Funki​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#configuring-foundry-with-funki","content":" Next, you'll configure your Foundry project for deploying smart contracts to the Funki network. This two-step process involves storing your private key in an encrypted keystore and adding Funki as a network.  ","version":"Next","tagName":"h2"},{"title":"Storing your private key​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#storing-your-private-key","content":" To import your private key into Foundry's secure keystore, use the following command. You'll be prompted to enter your private key and create a password for transaction signing:  cast wallet import deployer --interactive   To retrieve your private key from Wallet, refer to the Coinbase Wallet documentation or Metamask Wallet documentation. Never commit your private key to a public repository.  Verify that the 'deployer' account is set up in Foundry by running:  cast wallet list   ","version":"Next","tagName":"h3"},{"title":"Adding Funki as a network​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#adding-funki-as-a-network","content":" To verify a contract with FunkiScan, you'll need an API key. Obtain your FunkiScan API key here after creating an account.  Create a .env file in your project's home directory to add the Funki network and your FunkiScan API key:  FUNKI_MAINNET_RPC=&quot;https://rpc-mainnet.funkichain.com&quot; FUNKI_TESTNET_RPC=&quot;https://funki-testnet.alt.technology&quot; ETHERSCAN_API_KEY=&quot;&lt;YOUR API KEY&gt;&quot;   Although you're using FunkiScan as your block explorer, Foundry requires the API key to be defined as ETHERSCAN_API_KEY.  ","version":"Next","tagName":"h3"},{"title":"Loading environment variables​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#loading-environment-variables","content":" After creating the .env file, load the environment variables in your current command line session with:  source .env     ","version":"Next","tagName":"h3"},{"title":"Deploying the Smart Contract​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#deploying-the-smart-contract","content":" With your contract compiled and environment configured, you're ready to deploy to the Funki testnet!  You'll use the forge create command—a straightforward way to deploy a single contract. For more complex projects, consider exploring forge script, which enables scripting on-chain transactions and deploying intricate smart contract systems.  Before proceeding, ensure you have testnet ETH in your wallet. If not, revisit the prerequisites to avoid deployment hiccups.  To deploy the contract to Funki Sepolia Testnet, execute the following command and enter the password you set when importing your private key:  forge create ./src/NFT.sol:NFT --rpc-url $FUNKI_TESTNET_RPC --account deployer   Once deployed, view the contract's status using a block explorer. Search for the address returned by your deploy script. If you've deployed an exact copy of the NFT contract above, it will be pre-verified, allowing you to interact with it via the web interface.  For mainnet deployment, modify the command:  forge create ./src/NFT.sol:NFT --rpc-url $FUNKI_MAINNET_RPC --account deployer   Remember, new or modified contracts require verification, regardless of the network.    ","version":"Next","tagName":"h2"},{"title":"Verifying the Smart Contract​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#verifying-the-smart-contract","content":" In web3, contract verification is crucial. It allows users and developers to inspect the source code and confirm it matches the deployed bytecode on the blockchain.  Verification is also necessary for others to interact with your contract via the block explorer. While the above contract is pre-verified, let's walk through the verification process on Funki testnet.  As of this writing, FunkiScan utilizes the RouteScan API. Their free tier doesn't require an API key and offers 2 requests per second (rps) with a daily limit of 10,000 calls. For more details, visit the RouterScan API Plans page.  To verify, grab the deployed address and run:  forge verify-contract &amp;lt;DEPLOYED_ADDRESS&amp;gt; ./src/NFT.sol:NFT --chain 33979 --watch   Confirm verification by searching for your contract on FunkiScan.  Note: You cannot re-verify a contract that has already been verified with identical code. Attempting to do so will result in an error.    ","version":"Next","tagName":"h2"},{"title":"Interacting with the Smart Contract​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#interacting-with-the-smart-contract","content":" After verifying your contract on FunkiScan, you can interact with it through the &quot;Read Contract&quot; and &quot;Write Contract&quot; sections under the &quot;Contract&quot; tab. To use the &quot;Write Contract&quot; feature, connect your wallet by clicking the &quot;Connect to Web3&quot; button. Be aware that you might need to click &quot;Connect&quot; twice to establish a successful connection.  To practice using Foundry's cast command-line tool, you'll perform a read operation without publishing a transaction, then sign and publish a write transaction.  ","version":"Next","tagName":"h2"},{"title":"Performing a call​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#performing-a-call","content":" cast, a core component of the Foundry toolkit, enables interaction with contracts, transaction sending, and on-chain data retrieval via Ethereum RPC calls. Let's begin by executing a read-only call from your account.  Enter this command in your terminal:  cast call &amp;lt;DEPLOYED_ADDRESS&amp;gt; --rpc-url $FUNKI_TESTNET_RPC &quot;balanceOf(address)&quot; &amp;lt;YOUR_ADDRESS_HERE&amp;gt;   You should receive 0x0000000000000000000000000000000000000000000000000000000000000000 in response, which equals 0 in hexadecimal. This makes sense—you've deployed the NFT contract, but no NFTs have been minted yet, so your account balance is zero.  ","version":"Next","tagName":"h3"},{"title":"Signing and publishing a transaction​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#signing-and-publishing-a-transaction","content":" Now, let's sign and publish a transaction by calling the mint(address) function on your newly deployed NFT contract.  Enter the following command in your terminal:  cast send &amp;lt;DEPLOYED_ADDRESS&amp;gt; --rpc-url=$FUNKI_TESTNET_RPC &quot;mint(address)&quot; &amp;lt;YOUR_ADDRESS_HERE&amp;gt; --account deployer   Note that this cast send command requires your private key, unlike cast call. The latter is for view-only functions and doesn't need signing.  Upon success, Foundry will display transaction details, including the blockNumber, gasUsed, and transactionHash.  To verify that you've minted an NFT, run the initial cast call command again. Your balance should now show an increase from 0 to 1:  cast call &amp;lt;DEPLOYED_ADDRESS&amp;gt; --rpc-url $FUNKI_TESTNET_RPC &quot;balanceOf(address)&quot; &amp;lt;YOUR_ADDRESS_HERE&amp;gt;   The response should be 0x0000000000000000000000000000000000000000000000000000000000000001 (1 in hex). Congratulations! You've successfully deployed a contract and minted an NFT using Foundry.    ","version":"Next","tagName":"h3"},{"title":"Interact with the Contract on FunkiScan​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#interact-with-the-contract-on-funkiscan","content":" You can now interact with your contract using FunkiChain. Click the Contract tab. If your contract is verified, you'll see the contract's source code and all its functions under the Read Contract and Write Contract buttons. Note that only write functions require an on-chain transaction.  To interact with write functions, you need to sign in to FunkiChain with your wallet. Currently, you can choose from any of the supported wallet providers that appear.    Once connected, you're all set to interact with any write function of the contract. Make sure your input is correct and double-check the transaction details before confirming any transaction.    ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a smart contract using Foundry","url":"/docs/tutorials/deploy-sm-using-foundry#conclusion","content":" Congratulations! You've accomplished a great deal. You've mastered project setup, deployment to Funki, and smart contract interaction using Foundry. This process applies to real networks too, albeit at a higher cost. Remember, thorough testing of your contracts is crucial to minimize the risk of bugs that could affect users before deployment.  For comprehensive Foundry resources, dive into the Foundry book. Need community support? Join the official Telegram dev chat or support chat. ","version":"Next","tagName":"h2"},{"title":"Deploying a smart contract using Hardhat","type":0,"sectionRef":"#","url":"/docs/tutorials/deploy-sm-using-hardhat","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#objectives","content":" By the end of this tutorial, you'll be able to:  Set up Hardhat for FunkiCreate an NFT smart contract for FunkiCompile a smart contract for FunkiDeploy a smart contract to FunkiInteract with a smart contract deployed on Funki    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#prerequisites","content":" ","version":"Next","tagName":"h2"},{"title":"Node v18+​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#node-v18","content":" This tutorial requires you have Node version 18+ installed.  Download Node v18+  If you are using nvm to manage your node versions, you can just run nvm install 18.  ","version":"Next","tagName":"h3"},{"title":"Web3 wallet​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#web3-wallet","content":" To deploy a smart contract, you'll need a web3 wallet. Create one by installing a wallet browser extension:  Install Coinbase WalletInstall MetaMask Wallet  ","version":"Next","tagName":"h3"},{"title":"Wallet Funds​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#wallet-funds","content":" Deploying contracts to the blockchain incurs gas fees. You'll need to fund your wallet with ETH to cover these costs.  For this tutorial, you'll deploy a contract to the FunkiSepolia. To obtain Sepolia ETH, use one of the faucets listed on the Funki Network Faucets page.    ","version":"Next","tagName":"h3"},{"title":"Creating a Project​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#creating-a-project","content":" Before deploying smart contracts to Funki, you'll need to set up your development environment by creating a Node.js project.  To create a new Node.js project, run:  npm init --y   Next, you will need to install Hardhat and create a new Hardhat project  To install Hardhat, run:  npm install --save-dev hardhat   To create a new Hardhat project, run:  npx hardhat init   Choose &quot;Create a TypeScript project,&quot; then press Enter to confirm the project root. Select &quot;y&quot; for both adding a .gitignore file and including the sample project. The setup process will take a few moments to finish.    ","version":"Next","tagName":"h2"},{"title":"Configuring Hardhat with Funki​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#configuring-hardhat-with-funki","content":" To deploy smart contracts to the Funki network, you'll need to configure your Hardhat project and add Funki as a network.  To configure Hardhat for Funki, add Funki as a network in your project's hardhat.config.ts file:  import { HardhatUserConfig } from 'hardhat/config'; import '@nomicfoundation/hardhat-toolbox'; require('dotenv').config(); const config: HardhatUserConfig = { solidity: { version: '0.8.23', }, networks: { // for mainnet 'funkiMainnet': { url: 'https://rpc-mainnet.funkichain.com', accounts: [process.env.WALLET_KEY as string], }, // for testnet 'funkiSepolia': { url: 'https://funki-testnet.alt.technology', accounts: [process.env.WALLET_KEY as string], }, // for local dev environment 'funkiLocal': { url: 'http://localhost:8545', accounts: [process.env.WALLET_KEY as string], }, }, defaultNetwork: 'hardhat', }; export default config;   ","version":"Next","tagName":"h2"},{"title":"Install Hardhat toolbox​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#install-hardhat-toolbox","content":" The configuration above utilizes the @nomicfoundation/hardhat-toolbox plugin. This plugin bundles all the commonly used packages and Hardhat plugins recommended for starting development with Hardhat.  To install @nomicfoundation/hardhat-toolbox, execute the following command:  npm install --save-dev @nomicfoundation/hardhat-toolbox   ","version":"Next","tagName":"h3"},{"title":"Loading Environment Variables​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#loading-environment-variables","content":" The configuration above uses dotenv to load the WALLET_KEY environment variable from a .env file into process.env.WALLET_KEY. This approach helps keep your private keys secure by avoiding hardcoding them in your source code.  To install dotenv, execute the following command:  npm install --save-dev dotenv   Once you have dotenv installed, you can create a .env file with the following content:  WALLET_KEY=&quot;&lt;YOUR_PRIVATE_KEY&gt;&quot;   Substituting &lt;YOUR_PRIVATE_KEY&gt; with the private key for your wallet.  warning WALLET_KEY is the private key of the wallet to use when deploying a contract. For instructions on how to get your private key from Metamask Wallet, visit the Metamask Wallett documentation or Coinbase Wallet documentation. It is critical that you do NOT commit this to a public repo  ","version":"Next","tagName":"h3"},{"title":"Local Networks​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#local-networks","content":" You can run the Funki network locally and deploy using it. It will take a very long time for your node to sync with the network. If you encounter errors stating that the nonce has already been used when attempting to deploy, it means your node isn't fully synced yet.  For quick testing, such as adding unit tests to the NFT contract below, you might prefer to keep the defaultNetwork as 'hardhat'.    ","version":"Next","tagName":"h3"},{"title":"Compiling the smart contract​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#compiling-the-smart-contract","content":" Below is a simple NFT smart contract (ERC-721) written in the Solidity programming language:  // SPDX-License-Identifier: MIT pragma solidity ^0.8.23; import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;; contract NFT is ERC721 { uint256 public currentTokenId; constructor() ERC721(&quot;NFT Name&quot;, &quot;NFT&quot;) {} function mint(address recipient) public payable returns (uint256) { uint256 newItemId = ++currentTokenId; _safeMint(recipient, newItemId); return newItemId; } }   The Solidity code above defines a smart contract named NFT. It utilizes the ERC721 interface from the OpenZeppelin Contracts library to create an NFT smart contract. OpenZeppelin enables developers to use battle-tested, standardized smart contract implementations that comply with official ERC standards.  To incorporate the OpenZeppelin Contracts library into your project, execute the following command:  npm install --save @openzeppelin/contracts   In your project, delete the contracts/Lock.sol contract that was generated with the project and add the above code in a new file called contracts/NFT.sol. (You can also delete the test/Lock.ts test file, but it's highly recommended to add your own tests as soon as possible.)  To compile the contract using Hardhat, run:  npx hardhat compile     ","version":"Next","tagName":"h2"},{"title":"Deploying the smart contract​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#deploying-the-smart-contract","content":" Once your contract has been successfully compiled, you can deploy the contract to the FunkiSepolia.  To deploy the contract to the FunkiSepolia, you'll need to modify the scripts/deploy.ts in your project:  import { ethers } from 'hardhat'; async function main() { const nft = await ethers.deployContract('NFT'); await nft.waitForDeployment(); console.log('NFT Contract Deployed at ' + nft.target); } // We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main().catch((error) =&gt; { console.error(error); process.exitCode = 1; });   You'll also need testnet ETH in your wallet. See the prerequisites if you haven't done that yet. Otherwise, the deployment attempt will fail.  Finally, run:  npx hardhat run scripts/deploy.ts --network funkiSepolia   The contract will be deployed on the FunkiSepolia. You can check the deployment status and view the contract using a block explorer by searching for the address provided by your deploy script. If you've deployed an exact copy of the NFT contract described above, it will be pre-verified, allowing you to interact with it directly through the web interface.  info If you'd like to deploy to mainnet, you'll modify the command like so: npx hardhat run scripts/deploy.ts --network funkiMainnet   Regardless of the network you're deploying to, if you're deploying a new or modified contract, you'll need to verify it first.    ","version":"Next","tagName":"h2"},{"title":"Verifying the Smart Contract​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#verifying-the-smart-contract","content":" To interact with your contract on the block explorer, you or someone else needs to verify it first. The contract we've discussed has already been verified, so you should be able to view your deployed version on a block explorer immediately. For the rest of this tutorial, we'll guide you through verifying your contract on the FunkiSepolia.  In your hardhat.config.ts file, set up FunkiSepolia as a custom network. Add the following configuration to your HardhatUserConfig:  etherscan: { apiKey: { &quot;funkiSepolia&quot;: &quot;PLACEHOLDER_STRING&quot; }, customChains: [ { network: &quot;funkiSepolia&quot;, chainId: 3397901, urls: { apiURL: &quot;https://api.routescan.io/v2/network/testnet/evm/3397901/etherscan/api&quot;, browserURL: &quot;http://testnet.funkiscan.io/&quot; } } ] },   Or using the RouterScan API for contract verification. Currently, no API key is required, and your requests fall under their free plan.  As of writing these docs, the RouteScan API free tier allows you to use the API without an API key, offering up to 2 requests per second (rps) and a daily limit of 10,000 calls. Read more at RouterScan API Plans  To verify a contract on FunkiSepolia, simply switch the chain information to FunkiSepolia. Currently, FunkiSepolia is an L2 of Sepolia Testnet, and its explorer is publicly available at Funki Testnet Explorer  Now, you can verify your contract on the Testnet. First, grab the deployed address and run:  npx hardhat verify --network funkiSepolia &lt;deployed address&gt;   For Mainnet, simply change the network parameter:  npx hardhat verify --network funkiMainet &lt;deployed address&gt;   info You can't re-verify a contract identical to one that has already been verified. If you attempt to do so—for instance, verifying the contract we've discussed—you'll receive an error message similar to: Error in plugin @nomiclabs/hardhat-etherscan: The API responded with an unexpected message. Contract verification may have succeeded and should be checked manually. Message: Already Verified To confirm your contract is verified, search for it on the explorer.    ","version":"Next","tagName":"h2"},{"title":"Interact with the Contract on FunkiScan​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#interact-with-the-contract-on-funkiscan","content":" You can now interact with your contract using FunkiChain. Click the Contract tab. If your contract is verified, you'll see the contract's source code and all its functions under the Read Contract and Write Contract buttons. Note that only write functions require an on-chain transaction.  To interact with write functions, you need to sign in to FunkiChain with your wallet. Currently, you can choose from any of the supported wallet providers that appear.    Once connected, you're all set to interact with any write function of the contract. Make sure your input is correct and double-check the transaction details before confirming any transaction.    ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a smart contract using Hardhat","url":"/docs/tutorials/deploy-sm-using-hardhat#conclusion","content":" We've covered deploying an NFT smart contract on FunkiSepolia using Hardhat. Here's what you need to know:  Hardhat streamlines smart contract development with deployment, testing, and debugging tools.To set up a Hardhat project, configure networks, manage environment variables, and write Solidity code.Deployment involves compiling the contract, running scripts, and verifying on the blockchain explorer.Protect your private keys and never commit sensitive information to public repositories.After deployment and verification, interact with your contract through the blockchain explorer. ","version":"Next","tagName":"h2"},{"title":"Get Started","type":0,"sectionRef":"#","url":"/docs/tutorials/connect-walletconnect-appkit","content":"","keywords":"","version":"Next"},{"title":"React​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#react","content":" AppKit supports Wagmi and Ethers v6 on Ethereum. Choose one of these Ethereum libraries to begin.  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#installation","content":" yarn add @web3modal/wagmi wagmi viem @tanstack/react-query   ","version":"Next","tagName":"h3"},{"title":"Cloud Configuration​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#cloud-configuration","content":" Create a new project on WalletConnect Cloud at https://cloud.walletconnect.com and obtain your project ID.  ","version":"Next","tagName":"h3"},{"title":"Implementation​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#implementation","content":" For quick integration, use the defaultWagmiConfig function, which wraps Wagmi's createConfig function with a predefined setup. This includes WalletConnect, Coinbase, and Injected connectors, as well as the Blockchain API as a transport.  Set up the following configuration at the top of your app, ensuring all functions are called outside any React component to prevent unwanted rerenders.  import { createWeb3Modal } from '@web3modal/wagmi/react' import { defaultWagmiConfig } from '@web3modal/wagmi/react/config' import { WagmiProvider } from 'wagmi' import { arbitrum, mainnet } from 'wagmi/chains' import { QueryClient, QueryClientProvider } from '@tanstack/react-query' // 0. Setup queryClient const queryClient = new QueryClient() // 1. Get projectId from https://cloud.walletconnect.com const projectId = 'YOUR_PROJECT_ID' // 2. Create wagmiConfig const metadata = { name: 'AppKit', description: 'AppKit Example', url: 'https://web3modal.com', // origin must match your domain &amp; subdomain icons: ['https://avatars.githubusercontent.com/u/37784886'] } const chains = [mainnet, arbitrum] as const const config = defaultWagmiConfig({ chains, projectId, metadata, }) // 3. Create modal createWeb3Modal({ metadata, wagmiConfig: config, projectId, enableAnalytics: true // Optional - defaults to your Cloud configuration }) export function AppKitProvider({ children }) { return ( &lt;WagmiProvider config={config}&gt; &lt;QueryClientProvider client={queryClient}&gt;{children}&lt;/QueryClientProvider&gt; &lt;/WagmiProvider&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Trigger the modal​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#trigger-the-modal","content":" To open AppKit, you can use our web component or build your own button with AppKit hooks. In this example, we'll use the &amp;lt;w3m-button&amp;gt; component.  Web components are global HTML elements that don't require importing.  export default function ConnectButton() { return &lt;w3m-button /&gt; }   Learn more about the AppKit web components here  ","version":"Next","tagName":"h3"},{"title":"Smart Contract Interaction​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#smart-contract-interaction","content":" Wagmi hooks can help us interact with wallets and smart contracts:  import { useReadContract } from 'wagmi' import { USDTAbi } from '../abi/USDTAbi' const USDTAddress = '0x...' function App() { const result = useReadContract({ abi: USDTAbi, address: USDTAddress, functionName: 'totalSupply' }) }   Read more about Wagmi hooks for smart contract interaction here.    ","version":"Next","tagName":"h3"},{"title":"Android​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#android","content":" Kotlin implementation of AppKit for Android applications.  Android Core  https://img.shields.io/maven-central/v/com.walletconnect/android-core  Web3Modal  https://img.shields.io/maven-central/v/com.walletconnect/web3modal  ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#requirements","content":" Android min SDK 23Java 11  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#installation-1","content":" root/build.gradle.kts:  allprojects { repositories { mavenCentral() maven { url &quot;https://jitpack.io&quot; } } }   app/build.gradle.kts  implementation(platform(&quot;com.walletconnect:android-bom:$BOM_VERSION&quot;)) implementation(&quot;com.walletconnect:android-core&quot;) implementation(&quot;com.walletconnect:web3modal&quot;)   ","version":"Next","tagName":"h3"},{"title":"Implementation​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#implementation-1","content":" Web3Modal is a singleton that interacts with the WalletConnectModal SDK.  Initialize  val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL val projectId = &quot;&quot; // Get Project ID at https://cloud.walletconnect.com/ val appMetaData = Core.Model.AppMetaData( name = &quot;Kotlin.Web3Modal&quot;, description = &quot;Kotlin Web3Modal Implementation&quot;, url = &quot;kotlin.walletconnect.com&quot;, icons = listOf(&quot;https://raw.githubusercontent.com/WalletConnect/walletconnect-assets/master/Icon/Gradient/Icon.png&quot;), redirect = &quot;kotlin-web3modal://request&quot; ) CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData) Web3Modal.initialize( init = Modal.Params.Init(CoreClient), onSuccess = { // Callback will be called if initialization is successful }, onError = { error -&gt; // Error will be thrown if there's an issue during initialization } )   Session properties  You can define session properties by calling the setSessionProperties method on the Web3Modal object.  Chains  This example defines an Ethereum chain. You can specify the chains you want to use, but they must be EVM compatible.  // Example of definition chains: https://github.com/WalletConnect/WalletConnectKotlinV2/blob/master/product/web3modal/src/main/kotlin/com/walletconnect/web3/modal/presets/Web3ModalChainsPresets.kt Web3Modal.setChains(Web3ModalChainsPresets.ethChains.values.toList())   IMPORTANT: Chains must be set before opening the modal.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#usage","content":" import androidx.compose.material.ExperimentalMaterialApi import androidx.compose.material.ModalBottomSheetState import androidx.navigation.compose.NavHost import androidx.navigation.compose.composable import androidx.navigation.compose.rememberNavController import com.google.accompanist.navigation.material.BottomSheetNavigator import com.google.accompanist.navigation.material.ExperimentalMaterialNavigationApi import com.google.accompanist.navigation.material.ModalBottomSheetLayout import com.google.accompanist.navigation.material.bottomSheet import com.walletconnect.web3.modal.ui.web3ModalGraph setContent { val modalSheetState = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden, skipHalfExpanded = true) val bottomSheetNavigator = BottomSheetNavigator(modalSheetState) val navController = rememberNavController(bottomSheetNavigator) ModalBottomSheetLayout(bottomSheetNavigator = bottomSheetNavigator) { NavHost( navController = navController, startDestination = &quot;home&quot; ) { composable(&quot;home&quot;) { HomeScreen() } web3ModalGraph(navController) } } }   IMPORTANT: Web3Modal uses accompanist navigation material inside. ModalBottomSheetLayout should be imported from Accompanist Navigation Material  import com.walletconnect.web3.modal.ui.openWeb3Modal navController().openWeb3Modal( shouldOpenChooseNetwork = true | false onError = { } )     ","version":"Next","tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#ios","content":" ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#installation-2","content":" Swift Package Manager  You can add AppKit to your project using Swift Package Manager. Follow these steps:  Open XcodeGo to File → Add PackagesPaste the GitHub repository URL: https://github.com/WalletConnect/web3modal-swiftClick &quot;Add Package&quot;Select the Web3Modal products you want to install in your app  Alternative: Add Web3Modal to a Package.swift manifest  To integrate via a Package.swift manifest instead of Xcode, add Web3Modal to your package's dependencies array:  dependencies: [ .package( name: &quot;Web3Modal&quot;, url: &quot;https://github.com/WalletConnectV2/web3modal-swift.git&quot;, .upToNextMajor(from: &quot;1.0.13&quot;) ), // Any other dependencies you have... ],   Then, in any target that depends on a Web3Modal product, add it to the dependenciesarray of that target:  .target( name: &quot;MyTargetName&quot;, dependencies: [ // The product(s) you want (most likely Web3Modal). .product(name: &quot;Web3Modal&quot;, package: &quot;Web3Modal&quot;), ] ),   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Get Started","url":"/docs/tutorials/connect-walletconnect-appkit#usage-1","content":" Configure Networking and Pair Clients  Before proceeding, ensure you've properly configured the Networking and Pair Clients.  Initialize Web3Modal Client  To initialize the client, simply call the configure method from the Web3Modal instance wrapper.  let metadata = AppMetadata( name: &quot;Example Wallet&quot;, description: &quot;Wallet description&quot;, url: &quot;example.wallet&quot;, icons: [&quot;https://avatars.githubusercontent.com/u/37784886&quot;], // Used for the Verify: to opt-out verification ignore this parameter verifyUrl: &quot;verify.walletconnect.com&quot; ) Web3Modal.configure( projectId: PROJECT_ID, metadata: metadata )   This example will default to using following namespaces.  let methods: Set&lt;String&gt; = [&quot;eth_sendTransaction&quot;, &quot;personal_sign&quot;, &quot;eth_signTypedData&quot;] let events: Set&lt;String&gt; = [&quot;chainChanged&quot;, &quot;accountsChanged&quot;] let blockchains: Set&lt;Blockchain&gt; = [Blockchain(&quot;eip155:1&quot;)!] let namespaces: [String: ProposalNamespace] = [ &quot;eip155&quot;: ProposalNamespace( chains: blockchains, methods: methods, events: events ) ] let defaultSessionParams = SessionParams( requiredNamespaces: namespaces, optionalNamespaces: nil, sessionProperties: nil )   IIf you want to customize the session parameters, you can call configure and define your own like this:  let metadata = AppMetadata(...) let sessionParams = SessionParams(...) Web3Modal.configure( projectId: PROJECT_ID, metadata: metadata, sessionParams: sessionParams )   Alternatively, you can modify them later using Web3Modal.set(sessionParams: SessionParams(...))  Provided UI components  You can now utilize the Web3ModalButton or Web3ModalNetworkButton components. These components dynamically reflect the Web3Modal client's state, including session status, account address and balance, and the currently selected network. They automatically update when the state changes. For more detailed examples, check out the Sample app's ContentView.swift.  Custom UI  If you want to use a custom UI, you can present the modal by simply calling:  Web3Modal.present()   This method will traverse the view hierarchy and attempt to present from the topmost controller. It's primarily designed for SwiftUI applications.  Alternatively, you can specify the view controller to present from:  Web3Modal.present(from: viewController)   Subscribe to Web3Modal Publishers  The following publishers are available for subscription:  public var sessionPublisher: AnyPublisher&lt;[Session], Never&gt; public var sessionSettlePublisher: AnyPublisher&lt;Session, Never&gt; public var sessionRejectionPublisher: AnyPublisher&lt;(Session.Proposal, Reason), Never&gt; public var sessionDeletePublisher: AnyPublisher&lt;(String, Reason), Never&gt; public var sessionResponsePublisher: AnyPublisher&lt;Response, Never&gt; public var socketConnectionStatusPublisher: AnyPublisher&lt;SocketConnectionStatus, Never&gt; public var authResponsePublisher: AnyPublisher&lt;(id: RPCID, result: Result&lt;(Session?, [Cacao]), AuthError&gt;), Never&gt;   Sign methods  Web3Modal internally uses the Sign SDK, and most of its methods are exposed through the Web3Modal interface. ","version":"Next","tagName":"h3"},{"title":"Simple NFTs","type":0,"sectionRef":"#","url":"/docs/tutorials/simple-nfts","content":"","keywords":"","version":"Next"},{"title":"Objectives​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#objectives","content":" By the end of this tutorial, you'll learn how to:  Generate and return JSON metadata for ERC-721 tokens programmaticallyCreate unique SVG art deterministically within a smart contractProduce deterministic, pseudorandom numbers    ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#prerequisites","content":" ","version":"Next","tagName":"h2"},{"title":"ERC-721 Tokens​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#erc-721-tokens","content":" This tutorial assumes you can write, test, and deploy ERC-721 tokens using Solidity. If you need to brush up on these skills first, check out some introductory resources.  ","version":"Next","tagName":"h3"},{"title":"Vector Art​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#vector-art","content":" You'll need familiarity with the SVG format and basic skills in editing and manipulating vector art. Don't have these? No worries—grab an artsy friend and team up!!    ","version":"Next","tagName":"h3"},{"title":"Building Smart Contract​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#building-smart-contract","content":" Begin by setting up an OpenZeppelin ERC-721 contract. You'll need to create a mintTo function that accepts the recipient's address for the NFT.  // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.24; import &quot;hardhat/console.sol&quot;; import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;; contract RandomColorNFT is ERC721 { uint public counter; constructor() ERC721(&quot;RandomColorNFT&quot;, &quot;RCNFT&quot;) {} function mintTo(address _to) public { counter++; _safeMint(_to, counter); } }   When using Smart Wallet, msg.sender represents the user's custodial address—the intended NFT recipient. However, this isn't always true with account abstraction. In some implementations, msg.sender might be the smart contract address, even if the user signs in with an EOA. As a result, it's becoming standard practice to explicitly pass the desired NFT recipient's address.  ","version":"Next","tagName":"h2"},{"title":"Offchain Metadata​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#offchain-metadata","content":"   You can skip this section if you prefer to make your metadata fully on-chain.  This approach enables the smart contract to retrieve NFT metadata via an API server URL. You have the flexibility to deploy your metadata API on various platforms: IPFS, cloud storage, or your own servers.  For reference, sample API servers are available in both Python and NodeJS.  Essentially, we'll configure the tokenURI function to return a result like this:    In this example, the API is a public endpoint that returns JSON data as follows:  // 20240823144509 // https://api-dashboard.atherlabs.xyz/api/sipher/loyalty/uri/erc721/INU/123 { &quot;name&quot;: &quot;Sipher INU #8234&quot;, &quot;attributes&quot;: [ { &quot;trait_type&quot;: &quot;background&quot;, &quot;value&quot;: &quot;blue smoke&quot; }, { &quot;trait_type&quot;: &quot;costume&quot;, &quot;value&quot;: &quot;sheriff jacket&quot; }, { &quot;trait_type&quot;: &quot;eye color&quot;, &quot;value&quot;: &quot;green&quot; }, { &quot;trait_type&quot;: &quot;fur color&quot;, &quot;value&quot;: &quot;brown&quot; }, { &quot;trait_type&quot;: &quot;hand&quot;, &quot;value&quot;: &quot;spike glove&quot; }, { &quot;trait_type&quot;: &quot;mask&quot;, &quot;value&quot;: &quot;gas mask&quot; }, { &quot;trait_type&quot;: &quot;secondary background color&quot;, &quot;value&quot;: &quot;pink&quot; }, { &quot;trait_type&quot;: &quot;sub-race&quot;, &quot;value&quot;: &quot;Canis&quot; }, { &quot;trait_type&quot;: &quot;weapon&quot;, &quot;value&quot;: &quot;metal pipe&quot; } ], &quot;description&quot;: &quot;&quot;, &quot;external_url&quot;: &quot;https://playsipher.com&quot;, &quot;image&quot;: &quot;https://sipherstorage.s3.ap-southeast-1.amazonaws.com/imgs/shiba_008234_mask.png&quot; }   To implement this, override the _baseURI() function to return your API URL. In this example, we override it to return the baseURI variable:  function _baseURI() internal view override returns (string memory) { return baseURI; }   You can set your baseURI in the constructor or create a setBaseURI() function for easy updates:  function setBaseURI(string calldata _uri) external onlyRole(MANAGER_ROLE) { baseURI = _uri; }   With this setup, the OpenZeppelin library's tokenURI() function will automatically combine your API URL with the input tokenId, creating a complete API call:  function tokenURI(uint256 tokenId) public view virtual returns (string memory) { _requireOwned(tokenId); string memory baseURI = _baseURI(); return bytes(baseURI).length &gt; 0 ? string.concat(baseURI, tokenId.toString()) : &quot;&quot;; }   By managing your API's output, you can provide unique metadata for each NFT tokenId.  ","version":"Next","tagName":"h2"},{"title":"Onchain Metadata​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#onchain-metadata","content":" Skip this section if you've already implemented your metadata off-chain.  Instead of referencing a json file hosted on a traditional web server, you can store your metadata directly in the contract. To implement this, first import these helper libraries:  import &quot;@openzeppelin/contracts/utils/Base64.sol&quot;; import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;   Then, override the _baseURI and tokenURI functions to return Base64-encoded JSON metadata containing the relevant information:  function _baseURI() internal pure override returns (string memory) { return &quot;data:application/json;base64,&quot;; } function tokenURI(uint _tokenId) public view override returns (string memory) { if(_tokenId &gt; counter) { revert InvalidTokenId(_tokenId); } string memory json = Base64.encode( bytes( string( abi.encodePacked( '{&quot;name&quot;: &quot;', name(), ' #: ', Strings.toString(_tokenId), '&quot;,&quot;description&quot;: &quot;Random colors are pretty or boring!&quot;, &quot;image&quot;: &quot;image&quot;: &quot;data:image/svg+xml;base64,', // TODO..., '&quot;}' ) ) ) ); return string(abi.encodePacked(_baseURI(), json)); }   Exercise extreme caution when setting up the single and double quotes above. Always test this function thoroughly to ensure it produces valid JSON metadata. A single error here can break the NFT, preventing it from displaying correctly in wallets or marketplaces!  ","version":"Next","tagName":"h2"},{"title":"Onchain SVG Image​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#onchain-svg-image","content":" The NFT's art will feature a simple SVG containing a square with a pseudo-randomly chosen color, all stored directly on the blockchain.  Let's start by creating a render function:  function render(uint _tokenId) public view returns (string memory) { return string( abi.encodePacked( &quot;&amp;lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1024 1024'&amp;gt;&quot;, // TODO: add a rectangle with a random color fill &quot;&amp;lt;/svg&amp;gt;&quot; ) ); }   In SVG, rectangles are created using the [rect] element. To fill the entire background, set the width and height to match the viewbox dimensions. While not explicitly mentioned in the MDN documentation for rectangles, you can use the fill property to add color to any SVG element. Color can be specified using names or hex codes:  &lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;#aabbcc&quot; /&gt;   ","version":"Next","tagName":"h3"},{"title":"Generating a Random Color​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#generating-a-random-color","content":" Instead of a fixed color, your design requires a unique color for each NFT. Add a function to generate this:  // Function to generate a random color hex code function generateRandomColor() public view returns (string memory) { // Generate a pseudo-random number using block.prevrandao uint256 randomNum = uint256(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, msg.sender))); // Extract RGB components from the random number bytes memory colorBytes = new bytes(3); colorBytes[0] = bytes1(uint8(randomNum &gt;&gt; 16)); colorBytes[1] = bytes1(uint8(randomNum &gt;&gt; 8)); colorBytes[2] = bytes1(uint8(randomNum)); // Convert RGB components to hex string string memory colorHex = string(abi.encodePacked( &quot;#&quot;, toHexDigit(uint8(colorBytes[0]) &gt;&gt; 4), toHexDigit(uint8(colorBytes[0]) &amp; 0x0f), toHexDigit(uint8(colorBytes[1]) &gt;&gt; 4), toHexDigit(uint8(colorBytes[1]) &amp; 0x0f), toHexDigit(uint8(colorBytes[2]) &gt;&gt; 4), toHexDigit(uint8(colorBytes[2]) &amp; 0x0f) )); return colorHex; } // Helper function to convert a uint8 to a hex character function toHexDigit(uint8 d) internal pure returns (bytes1) { if (d &lt; 10) { return bytes1(uint8(bytes1('0')) + d); } else { return bytes1(uint8(bytes1('a')) + d - 10); } }   Caution: Randomness generated using on-chain information isn't fully secure. A determined attacker could manipulate a block to compromise your contract. That said, prevrandao is a passable solution for non-high-stakes applications.  ","version":"Next","tagName":"h3"},{"title":"Saving the Color to the NFT​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#saving-the-color-to-the-nft","content":" To associate each NFT with its generated color, you'll need to store this information for retrieval when the tokenURI function is called. Add a mapping to establish this relationship:  mapping (uint =&gt; string) public tokenIdToColor;   Then, set the color during the minting process:  function mintTo(address _to) public { counter++; _safeMint(_to, counter); tokenIdToColor[counter] = generateRandomColor(); }   ","version":"Next","tagName":"h3"},{"title":"Completing the tokenURI Function​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#completing-the-tokenuri-function","content":" Update your render function to generate the SVG:  function render(uint _tokenId) public view returns (string memory) { return string( abi.encodePacked( &quot;&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1024 1024'&gt;&quot;, &quot;&lt;rect width='1024' height='1024' fill='&quot;, tokenIdToColor[_tokenId], &quot;' /&gt;&quot;, &quot;&lt;/svg&gt;&quot; ) ); }   Finally, modify your tokenURI function to incorporate the SVG and return it as base64-encoded data:  function tokenURI(uint _tokenId) public view override returns (string memory) { if(_tokenId &gt; counter) { revert InvalidTokenId(_tokenId); } string memory json = Base64.encode( bytes( string( abi.encodePacked( '{&quot;name&quot;: &quot;', name(), ' #: ', Strings.toString(_tokenId), '&quot;,&quot;description&quot;: &quot;Random colors are pretty or boring!&quot;, &quot;image&quot;: &quot;data:image/svg+xml;base64,', Base64.encode(bytes(render(_tokenId))), '&quot;}' ) ) ) ); return string(abi.encodePacked(_baseURI(), json)); }   ","version":"Next","tagName":"h3"},{"title":"List of NFTs Owned​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#list-of-nfts-owned","content":" Standard ERC-721 contracts don't provide a built-in way to list all NFTs owned by an address. This is due to gas costs, as the data is typically accessed through off-chain services.  However, recent gas price reductions make on-contract ownership tracking more feasible, potentially reducing reliance on external APIs.  To track ownership in-contract, start by importing EnumerableSet from OpenZeppelin:  import &quot;@openzeppelin/contracts/utils/structs/EnumerableSet.sol&quot;;   Next, enable it for uint sets and add a mapping to link addresses to token IDs:  // Inside the RandomColorNFT contract using EnumerableSet for EnumerableSet.UintSet; mapping (address =&gt; EnumerableSet.UintSet) tokensOwned;   Lastly, use the _update function to handle ownership changes, including minting:  function _update(address to, uint256 tokenId, address auth) internal override(ERC721) returns(address) { // Only remove the token if it is not being minted if (tokenId != counter){ tokensOwned[auth].remove(tokenId); } tokensOwned[to].add(tokenId); return super._update(to, tokenId, auth); }   With this list of NFTs owned by an address, you can now create a function to retrieve them all. Include the JSON metadata for each token to get the complete list of NFTs and their metadata in a single RPC call!  function getNFftsOwned(address owner) public view returns (TokenAndMetatdata[] memory) { TokenAndMetatdata[] memory tokens = new TokenAndMetatdata[](tokensOwned[owner].length()); for (uint i = 0; i &lt; tokensOwned[owner].length(); i++) { uint tokenId = tokensOwned[owner].at(i); tokens[i] = TokenAndMetatdata(tokenId, tokenURI(tokenId)); } return tokens; }   ","version":"Next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#testing","content":" Test your contract locally, then deploy and verify it. Ensure proper formatting of JSON metadata and SVG image. To confirm functionality, check the collection on a testnet NFT marketplace.  Note: Collection registration may take a few minutes. If display issues occur, use a blockchain explorer to retrieve the tokenURI, then decode the base64 data to inspect the metadata and image.  ","version":"Next","tagName":"h2"},{"title":"Deploy Contract​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#deploy-contract","content":" To deploy the contract, you can refer to our tutorials that suit your preferred tech stack:  Deploying a smart contract using FoundryDeploying a smart contract using HardhatDeploying a smart contract using Remix  ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Simple NFTs","url":"/docs/tutorials/simple-nfts#conclusion","content":" This tutorial has equipped you with the skills to create a simple yet powerful NFT (Non-Fungible Token) with both off-chain and on-chain metadata. You've learned to generate and return JSON metadata for ERC-721 tokens programmatically, craft unique SVG art deterministically within a smart contract, and produce pseudorandom numbers for color generation. This knowledge forms a solid foundation for developing more sophisticated NFT projects and understanding the intricacies of on-chain data storage in blockchain applications. ","version":"Next","tagName":"h2"},{"title":"Connect to MetaMask using third-party libraries","type":0,"sectionRef":"#","url":"/docs/tutorials/connect-metamask","content":"","keywords":"","version":"Next"},{"title":"Vanilla TypeScript​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#vanilla-typescript","content":" Follow these steps to create a vanilla TypeScript project that connects to MetaMask:  ","version":"Next","tagName":"h2"},{"title":"1. Create a project​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#1-create-a-project","content":" Set up a Vite project using the vanilla TypeScript template:  npm create vite@latest vanilla-ts-6963 -- --template vanilla-ts   ","version":"Next","tagName":"h3"},{"title":"2. Set up the project​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#2-set-up-the-project","content":" In your Vite project, update src/vite-env.d.ts with the EIP-6963 interfaces:  /// &lt;reference types=&quot;vite/client&quot; /&gt; interface EIP6963ProviderInfo { rdns: string uuid: string name: string icon: string } interface EIP6963ProviderDetail { info: EIP6963ProviderInfo provider: EIP1193Provider } type EIP6963AnnounceProviderEvent = { detail: { info: EIP6963ProviderInfo provider: Readonly&lt;EIP1193Provider&gt; } } interface EIP1193Provider { isStatus?: boolean host?: string path?: string sendAsync?: ( request: { method: string; params?: Array&lt;unknown&gt; }, callback: (error: Error | null, response: unknown) =&gt; void ) =&gt; void send?: ( request: { method: string; params?: Array&lt;unknown&gt; }, callback: (error: Error | null, response: unknown) =&gt; void ) =&gt; void request: (request: { method: string params?: Array&lt;unknown&gt; }) =&gt; Promise&lt;unknown&gt; }   Note: In addition to the EIP-6963 interfaces, you need an EIP1193Provider interface (defined byEIP-1193). This interface is the foundational structure for Ethereum wallet providers and represents the essential properties and methods for interacting with MetaMask and other Ethereum wallets in JavaScript.  ","version":"Next","tagName":"h3"},{"title":"3. Update main.ts​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#3-update-maints","content":" Update src/main.ts with the following code:  import &quot;./style.css&quot; import { listProviders } from &quot;./providers.ts&quot; document.querySelector&lt;HTMLDivElement&gt;(&quot;#app&quot;)!.innerHTML = ` &lt;div&gt; &lt;div id=&quot;providerButtons&quot;&gt;&lt;/div&gt; &lt;/div&gt; ` listProviders(document.querySelector&lt;HTMLDivElement&gt;(&quot;#providerButtons&quot;)!)   The querySelector finds and returns the first HTML element that matches the CSS selector #app, and sets its innerHTML. Include a basic HTML structure with an inner div to inject a list of buttons, each representing a detected wallet provider.  You'll create the listProviders function in the next step, passing an argument that represents the div element.  ","version":"Next","tagName":"h3"},{"title":"4. Connect to wallets​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#4-connect-to-wallets","content":" Create a file src/providers.ts with the following code:  declare global { interface WindowEventMap { &quot;eip6963:announceProvider&quot;: CustomEvent } } // Connect to the selected provider using eth_requestAccounts. const connectWithProvider = async ( wallet: EIP6963AnnounceProviderEvent[&quot;detail&quot;] ) =&gt; { try { await wallet.provider.request({ method: &quot;eth_requestAccounts&quot; }) } catch (error) { console.error(&quot;Failed to connect to provider:&quot;, error) } } // Display detected providers as connect buttons. export function listProviders(element: HTMLDivElement) { window.addEventListener( &quot;eip6963:announceProvider&quot;, (event: EIP6963AnnounceProviderEvent) =&gt; { const button = document.createElement(&quot;button&quot;) button.innerHTML = ` &lt;img src=&quot;${event.detail.info.icon}&quot; alt=&quot;${event.detail.info.name}&quot; /&gt; &lt;div&gt;${event.detail.info.name}&lt;/div&gt; ` // Call connectWithProvider when a user selects the button. button.onclick = () =&gt; connectWithProvider(event.detail) element.appendChild(button) } ) // Notify event listeners and other parts of the dapp that a provider is requested. window.dispatchEvent(new Event(&quot;eip6963:requestProvider&quot;)) }   The connectWithProvider function connects the user to the selected provider using eth_requestAccounts. It takes a wallet object as an argument, which is of type EIP6963AnnounceProviderEvent[&quot;detail&quot;].  The listProviders function uses a streamlined approach. It directly passes the event.detail object to the connectWithProvider function when a provider is announced, rather than mapping and joining an entire block of HTML.  ","version":"Next","tagName":"h3"},{"title":"5. View the project​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#5-view-the-project","content":" Run the following command to view and test the Vite project in your browser:  npm run dev   ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#example","content":" For more information, check out the vanilla TypeScript example. You can clone the repository and run the example locally using npm i &amp;&amp; npm run dev.  ","version":"Next","tagName":"h3"},{"title":"React TypeScript​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#react-typescript","content":" Follow these steps for creating a React TypeScript project to connect to MetaMask:  ","version":"Next","tagName":"h2"},{"title":"1. Create a project​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#1-create-a-project-1","content":" Create a Vite project using the template for React TypeScript:  npm create vite@latest react-ts-6963 -- --template react-ts   ","version":"Next","tagName":"h3"},{"title":"2. Set up the project​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#2-set-up-the-project-1","content":" In your Vite project, update src/vite-env.d.ts with the EIP-6963 interfaces:  /// &lt;reference types=&quot;vite/client&quot; /&gt; interface EIP6963ProviderInfo { rdns: string uuid: string name: string icon: string } interface EIP6963ProviderDetail { info: EIP6963ProviderInfo provider: EIP1193Provider } type EIP6963AnnounceProviderEvent = { detail: { info: EIP6963ProviderInfo provider: Readonly&lt;EIP1193Provider&gt; } } interface EIP1193Provider { isStatus?: boolean host?: string path?: string sendAsync?: ( request: { method: string; params?: Array&lt;unknown&gt; }, callback: (error: Error | null, response: unknown) =&gt; void ) =&gt; void send?: ( request: { method: string; params?: Array&lt;unknown&gt; }, callback: (error: Error | null, response: unknown) =&gt; void ) =&gt; void request: (request: { method: string params?: Array&lt;unknown&gt; }) =&gt; Promise&lt;unknown&gt; }   Note: In addition to the EIP-6963 interfaces, you need a EIP1193Provider interface (defined byEIP-1193), which is the foundational structure for Ethereum wallet providers, and represents the essential properties and methods for interacting with MetaMask and other Ethereum wallets in JavaScript.  ","version":"Next","tagName":"h3"},{"title":"3. Update App.tsx​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#3-update-apptsx","content":" Update src/App.tsx with the following code:  import &quot;./App.css&quot; import { DiscoverWalletProviders } from &quot;./components/DiscoverWalletProviders&quot; function App() { return ( &lt;DiscoverWalletProviders/&gt; ) } export default App   This code renders the DiscoverWalletProviders component that you'll create in the next step, which contains the logic for detecting and connecting to wallet providers.  ","version":"Next","tagName":"h3"},{"title":"4. Detect and connect to wallets​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#4-detect-and-connect-to-wallets","content":" In the src/components directory, create a component DiscoverWalletProviders.tsx with the following code:  import { useState } from &quot;react&quot; import { useSyncProviders } from &quot;../hooks/useSyncProviders&quot; import { formatAddress } from &quot;~/utils&quot; export const DiscoverWalletProviders = () =&gt; { const [selectedWallet, setSelectedWallet] = useState&lt;EIP6963ProviderDetail&gt;() const [userAccount, setUserAccount] = useState&lt;string&gt;(&quot;&quot;) const providers = useSyncProviders() // Connect to the selected provider using eth_requestAccounts. const handleConnect = async (providerWithInfo: EIP6963ProviderDetail) =&gt; { try { const accounts = await providerWithInfo.provider.request({ method: &quot;eth_requestAccounts&quot; }) setSelectedWallet(providerWithInfo) setUserAccount(accounts?.[0]) } catch (error) { console.error(error) } } // Display detected providers as connect buttons. return ( &lt;&gt; &lt;h2&gt;Wallets Detected:&lt;/h2&gt; &lt;div&gt; { providers.length &gt; 0 ? providers?.map((provider: EIP6963ProviderDetail) =&gt; ( &lt;button key={provider.info.uuid} onClick={() =&gt; handleConnect(provider)} &gt; &lt;img src={provider.info.icon} alt={provider.info.name} /&gt; &lt;div&gt;{provider.info.name}&lt;/div&gt; &lt;/button&gt; )) : &lt;div&gt; No Announced Wallet Providers &lt;/div&gt; } &lt;/div&gt; &lt;hr /&gt; &lt;h2&gt;{userAccount ? &quot;&quot; : &quot;No &quot;}Wallet Selected&lt;/h2&gt; {userAccount &amp;&amp; &lt;div&gt; &lt;div&gt; &lt;img src={selectedWallet.info.icon} alt={selectedWallet.info.name} /&gt; &lt;div&gt;{selectedWallet.info.name}&lt;/div&gt; &lt;div&gt;({formatAddress(userAccount)})&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; } &lt;/&gt; ) }   In this code:  selectedWallet is a state variable that holds the user's most recently selected wallet.userAccount is a state variable that holds the user's connected wallet's address.useSyncProviders is a custom hook that returns the providers array (wallets installed in the browser).  The handleConnect function takes a providerWithInfo, which is an EIP6963ProviderDetail object. That object is used to request the user's accounts from the provider using eth_requestAccounts.  If the request succeeds, the selectedWallet and userAccount local state variables are set.  Then, the component maps over the providers array and renders a button for each detected provider.  Finally, if the userAccount state variable is not empty, the selected wallet icon, name, and address are displayed.  ","version":"Next","tagName":"h3"},{"title":"5. Add React hooks​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#5-add-react-hooks","content":" Create a src/hooks directory and add a store.ts file with the following code:  declare global { interface WindowEventMap { &quot;eip6963:announceProvider&quot;: CustomEvent } } // An array to store the detected wallet providers. let providers: EIP6963ProviderDetail[] = [] export const store = { value: () =&gt; providers, subscribe: (callback: () =&gt; void) =&gt; { function onAnnouncement(event: EIP6963AnnounceProviderEvent) { if (providers.map((p) =&gt; p.info.uuid).includes(event.detail.info.uuid)) return providers = [...providers, event.detail] callback() } // Listen for eip6963:announceProvider and call onAnnouncement when the event is triggered. window.addEventListener(&quot;eip6963:announceProvider&quot;, onAnnouncement) // Dispatch the event, which triggers the event listener in the MetaMask wallet. window.dispatchEvent(new Event(&quot;eip6963:requestProvider&quot;)) // Return a function that removes the event listern. return () =&gt; window.removeEventListener(&quot;eip6963:announceProvider&quot;, onAnnouncement) }, }   Also, add a file useSyncProviders.ts with the following code to the hooks directory:  import { useSyncExternalStore } from &quot;react&quot; import { store } from &quot;./store&quot; export const useSyncProviders = () =&gt; useSyncExternalStore(store.subscribe, store.value, store.value)   This hook allows you to subscribe to MetaMask events, read updated values, and update components. It uses the store.value and store.subscribe methods defined in the store.ts hook.  ","version":"Next","tagName":"h3"},{"title":"6. Create utility functions​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#6-create-utility-functions","content":" Create a src/utils directory and add a file index.ts with the following code:  export const formatBalance = (rawBalance: string) =&gt; { const balance = (parseInt(rawBalance) / 1000000000000000000).toFixed(2) return balance } export const formatChainAsNum = (chainIdHex: string) =&gt; { const chainIdNum = parseInt(chainIdHex) return chainIdNum } export const formatAddress = (addr: string) =&gt; { const upperAfterLastTwo = addr.slice(0, 2) + addr.slice(2) return `${upperAfterLastTwo.substring(0, 5)}...${upperAfterLastTwo.substring(39)}` }   This directory is ideal for storing utility functions that you may need to reuse throughout your dapp. While this example only utilizes the formatAddress function, the others could prove useful for various applications.  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Connect to MetaMask using third-party libraries","url":"/docs/tutorials/connect-metamask#example-1","content":" For a more comprehensive look, check out the React TypeScript example. You can clone the repository and run the example locally by executing npm i &amp;&amp; npm run dev. ","version":"Next","tagName":"h3"},{"title":"Prerequisites","type":0,"sectionRef":"#","url":"/docs/tutorials/interact-with-standard-bridge","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#overview","content":" Here is an end-to-end overview of how to execute a deposit transaction. We will break it down into Steps below.  import { getL2TransactionHashes } from 'viem/op-stack' import { account, publicClientL1, publicClientL2, walletClientL1 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1'), to: account.address, }) // Execute the deposit transaction on the L1. const hash = await walletClientL1.depositTransaction(args) // Wait for the L1 transaction to be processed. const receipt = await publicClientL1.waitForTransactionReceipt({ hash }) // Get the L2 transaction hash from the L1 transaction receipt. const [l2Hash] = getL2TransactionHashes(receipt) // Wait for the L2 transaction to be processed. const l2Receipt = await publicClientL2.waitForTransactionReceipt({ hash: l2Hash })     ","version":"Next","tagName":"h2"},{"title":"Steps​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#steps","content":" ","version":"Next","tagName":"h2"},{"title":"1. Set up Viem Clients​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#1-set-up-viem-clients","content":" First, we will set up our Viem Clients for the Mainnet and Funki chains, including the necessary extensions for the OP Stack.  We will place these in a config.ts file.  The example belows how to set up a Client for a JSON-RPC Account (Browser Extension, WalletConnect, etc)  // Import Viem modules. import { createPublicClient, createWalletClient, custom, http } from 'viem' import { mainnet, funki } from 'viem/chains' import { publicActionsL2, walletActionsL1 } from 'viem/op-stack' // Retrieve Account from an EIP-1193 Provider. export const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' }) export const publicClientL1 = createPublicClient({ chain: mainnet, transport: http() }) export const walletClientL1 = createWalletClient({ account, chain: mainnet, transport: custom(window.ethereum) }).extend(walletActionsL1()) export const publicClientL2 = createPublicClient({ chain: funki, transport: http() }).extend(publicActionsL2())   ","version":"Next","tagName":"h3"},{"title":"2. Build the Deposit Transaction​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#2-build-the-deposit-transaction","content":" Next, we will build the deposit transaction on the Funki (L2) chain using the Clients that we created in the previous step.  In the example below, we want to deposit 1 Ether (via mint) onto the Funki chain, to ourselves (account.address).  The mint value is the value to deposit (mint) on the Funki (L2) chain. It is debited from the account's Mainnet (L1) balance. You can also use someone else's address as the to value if you wanted to.  // Import Viem Clients. import { publicClientL2 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1') to: account.address, })   ","version":"Next","tagName":"h3"},{"title":"3. Execute the Deposit Transaction​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#3-execute-the-deposit-transaction","content":" After that, we will execute the deposit transaction on the Mainnet (L1) chain.  // Import Viem Clients. import { account, publicClientL2, walletClientL1 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1') to: account.address, }) // Execute the deposit transaction on the L1. const hash = await walletClientL1.depositTransaction(args)   ","version":"Next","tagName":"h3"},{"title":"4. Wait for Transaction to be Processed​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#4-wait-for-transaction-to-be-processed","content":" Once we have broadcast the transaction to the Mainnet (L1) chain, we need to wait for it to be processed on a block so we can extract the transaction receipt. We will need the transaction receipt to extract the transaction on the Funki (L2) chain.  When the transaction has been processed, the mint value (1 Ether) will be debited from the account's Mainnet (L1) balance.  // Import Viem Clients. import { account, publicClientL1, publicClientL2, walletClientL1 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1') to: account.address, }) // Execute the deposit transaction on the L1. const hash = await walletClientL1.depositTransaction(args) // Wait for the L1 transaction to be processed. const receipt = await publicClientL1.waitForTransactionReceipt({ hash })   ","version":"Next","tagName":"h3"},{"title":"5. Compute the L2 Transaction Hash​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#5-compute-the-l2-transaction-hash","content":" Once we have the transaction receipt from the Mainnet (L1) chain, we can extract the Funki (L2) transaction hash from the logs in the transaction receipt.  // Import Viem Clients. import { account, publicClientL1, publicClientL2, walletClientL1 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1') to: account.address, }) // Execute the deposit transaction on the L1. const hash = await walletClientL1.depositTransaction(args) // Wait for the L1 transaction to be processed. const receipt = await publicClientL1.waitForTransactionReceipt({ hash }) // Get the L2 transaction hash from the L1 transaction receipt. const [l2Hash] = getL2TransactionHashes(receipt)   ","version":"Next","tagName":"h3"},{"title":"6. Wait for Transaction to be Processed​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#6-wait-for-transaction-to-be-processed","content":" Now that we have the Funki (L2) transaction hash, we can wait for the transaction to be processed on the Funki (L2) chain.  Once the waitForTransactionReceipt call resolves, the transaction has been processed and you should now be credited with 1 Ether on the Funki (L2) chain 🥳  // Import Viem Clients. import { account, publicClientL1, publicClientL2, walletClientL1 } from './config' // Build parameters for the transaction on the L2. const args = await publicClientL2.buildDepositTransaction({ mint: parseEther('1') to: account.address, }) // Execute the deposit transaction on the L1. const hash = await walletClientL1.depositTransaction(args) // Wait for the L1 transaction to be processed. const receipt = await publicClientL1.waitForTransactionReceipt({ hash }) // Get the L2 transaction hash from the L1 transaction receipt. const [l2Hash] = getL2TransactionHashes(receipt) // Wait for the L2 transaction to be processed. const l2Receipt = await publicClientL2.waitForTransactionReceipt({ hash: l2Hash })     Withdrawals  This guide will demonstrate how to withdraw 1 Ether from Funki to Mainnet.  ","version":"Next","tagName":"h3"},{"title":"Overview​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#overview-1","content":" Withdrawals on Funki involve a three-step process:  Initiating the Withdrawal Transaction on L2 (Funki)  Wait up to one hour for the L2 Output containing the transaction to be proposed.  Proving the Withdrawal Transaction on L1 (Mainnet)  Wait for the 7-day finalization period  Finalizing the Withdrawal Transaction on L1 (Mainnet)  Withdrawal complete!  Below is a complete end-to-end overview of how to execute a withdrawal. Don't worry—we'll break it down into steps later.  import { getWithdrawals } from 'viem/op-stack' import { account, publicClientL1, walletClientL1, publicClientL2, walletClientL2 } from './config' // Build parameters to initiate the withdrawal transaction on the L1. const args = await publicClientL1.buildInitiateWithdrawal({ to: account.address, value: parseEther('1') }) // Execute the initiate withdrawal transaction on the L2. const hash = await walletClientL2.initiateWithdrawal(args) // Wait for the initiate withdrawal transaction receipt. const receipt = await publicClientL2.waitForTransactionReceipt({ hash }) // Wait until the withdrawal is ready to prove. const { output, withdrawal } = await publicClientL1.waitToProve({ receipt, targetChain: walletClientL2.chain }) // Build parameters to prove the withdrawal on the L2. const proveArgs = await publicClientL2.buildProveWithdrawal({ output, withdrawal, }) // Prove the withdrawal on the L1. const proveHash = await walletClientL1.proveWithdrawal(proveArgs) // Wait until the prove withdrawal is processed. const proveReceipt = await publicClientL1.waitForTransactionReceipt({ hash: proveHash }) // Wait until the withdrawal is ready to finalize. await publicClientL1.waitToFinalize({ targetChain: walletClientL2.chain, withdrawalHash: withdrawal.withdrawalHash, }) // Finalize the withdrawal. const finalizeHash = await walletClientL1.finalizeWithdrawal({ targetChain: walletClientL2.chain, withdrawal, }) // Wait until the withdrawal is finalized. const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({ hash: finalizeHash })     ","version":"Next","tagName":"h2"},{"title":"Steps​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#steps-1","content":" ","version":"Next","tagName":"h2"},{"title":"1. Set up Viem Clients​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#1-set-up-viem-clients-1","content":" First, we will set up our Viem Clients for the Mainnet and Funki chains, including the necessary extensions for the OP Stack.  We will need the following clients:  publicClientL1/walletClientL1: Public &amp; Wallet Client for MainnetpublicClientL2/walletClientL2: Public &amp; Wallet Client for Funki  We will place these in a config.ts file.  The example belows how to set up a Client for a JSON-RPC Account (Browser Extension, WalletConnect, etc)  // Import Viem modules. import { createPublicClient, createWalletClient, custom, http } from 'viem' import { mainnet, funki } from 'viem/chains' import { publicActionsL1, walletActionsL1, walletActionsL2 } from 'viem/op-stack' // Retrieve Account from an EIP-1193 Provider. export const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' }) export const publicClientL1 = createPublicClient({ chain: mainnet, transport: http() }).extend(publicActionsL1()) export const walletClientL1 = createWalletClient({ account, chain: mainnet, transport: custom(window.ethereum) }).extend(walletActionsL1()) export const publicClientL2 = createPublicClient({ chain: funki, transport: http() }) export const walletClientL2 = createWalletClient({ account, chain: funki, transport: custom(window.ethereum) }).extend(walletActionsL2())   ","version":"Next","tagName":"h3"},{"title":"2. Initiate Withdrawal​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#2-initiate-withdrawal","content":" Next, we will initiate the withdrawal transaction on the L2 by building the parameters on the L1 (1), and then executing the transaction on the L2 (2). We also want to wait for the L2 transaction to be processed on a block (3) before we continue.  In the example below, we are initiating a withdrawal for 1 Ether from the L2 (Funki) to the L1 (Mainnet).  import { account, publicClientL1, publicClientL2, walletClientL2 } from './config' // 1. Build parameters to initiate the withdrawal transaction on the L1. const args = await publicClientL1.buildInitiateWithdrawal({ to: account.address, value: parseEther('1') }) // 2. Execute the initiate withdrawal transaction on the L2. const hash = await walletClientL2.initiateWithdrawal(args) // 3. Wait for the initiate withdrawal transaction receipt. const receipt = await publicClientL2.waitForTransactionReceipt({ hash })   ","version":"Next","tagName":"h3"},{"title":"3. Prove Withdrawal​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#3-prove-withdrawal","content":" After the initiate withdrawal transaction has been processed on a block on the L2, we will then need to prove that withdrawal on the L1.  Before a withdrawal transaction can be proved, the transaction needs to be included in an L2 Output proposal. Until then, we will need to wait for the withdrawal transaction to be ready to be proved (1). This usually takes a maximum of one hour.  Once the L2 output has been proposed, we will need to build the parameters for the prove withdrawal transaction on the L2 (2), and then execute the transaction on the L1 (3). We also want to wait for the L1 transaction to be processed on a block (4) before we continue.  import { account, publicClientL1, publicClientL2, walletClientL1, walletClientL2 } from './config' // (Shortcut) Get receipt from transaction created in Step 1. const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' }) // 1. Wait until the withdrawal is ready to prove. const { output, withdrawal } = await publicClientL1.waitToProve({ receipt, targetChain: walletClientL2.chain }) // 2. Build parameters to prove the withdrawal on the L2. const args = await publicClientL2.buildProveWithdrawal({ output, withdrawal, }) // 3. Prove the withdrawal on the L1. const hash = await walletClientL1.proveWithdrawal(args) // 4. Wait until the prove withdrawal is processed. const receipt = await publicClientL1.waitForTransactionReceipt({ hash })   ","version":"Next","tagName":"h3"},{"title":"4. Finalize Withdrawal​","type":1,"pageTitle":"Prerequisites","url":"/docs/tutorials/interact-with-standard-bridge#4-finalize-withdrawal","content":" When the withdrawal transaction has been proved, we will then need to finalize that withdrawal on the L1.  Before a withdrawal transaction can be finalized, we will need to wait the finalization period of 7 days (1).  After the finalization period has elapsed, we can finalize the withdrawal (2).  Once the withdrawal has been successfully finalized (3), then the withdrawal is complete! 🥳  import { getWithdrawals } from 'viem/op-stack' import { account, publicClientL1, publicClientL2, walletClientL1, walletClientL2 } from './config' // (Shortcut) Get receipt from transaction created in Step 1. const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' }) // (Shortcut) Get withdrawals from receipt in Step 3. const [withdrawal] = getWithdrawals(receipt) // 1. Wait until the withdrawal is ready to finalize. await publicClientL1.waitToFinalize({ targetChain: walletClientL2.chain, withdrawalHash: withdrawal.withdrawalHash, }) // 2. Finalize the withdrawal. const hash = await walletClientL1.finalizeWithdrawal({ targetChain: walletClientL2.chain, withdrawal, }) // 3. Wait until the withdrawal is finalized. const receipt = await publicClientL1.waitForTransactionReceipt({ hash })  ","version":"Next","tagName":"h3"}],"options":{"languages":["en","de"],"id":"default"}}